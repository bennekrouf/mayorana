[
  {
    "id": "rust-error-handling-complete-guide",
    "slug": "rust-error-handling-complete-guide",
    "title": "Complete Guide to Rust Error Handling with Visual Examples",
    "date": "2025-07-28",
    "excerpt": "Master Rust's error handling with Result, Option, and custom errors. Includes visual diagrams, code examples with copy functionality, and cross-references to related concepts.",
    "content": "Error handling in Rust is fundamentally different from other languages. Instead of exceptions, Rust uses types like `Result<T, E>` and `Option<T>` to represent potential failures. This approach makes errors explicit and forces developers to handle them properly[^1].\n\n## The Error Handling Philosophy\n\nRust's approach to error handling is based on making errors visible in the type system:\n\n```mermaid\ngraph TD\n    A[Function Call] --> B{Can Fail?}\n    B -->|Yes| C[Result<T, E>]\n    B -->|No| D[Direct Value T]\n    C --> E{Handle Error}\n    E -->|Success| F[Extract T]\n    E -->|Failure| G[Handle E]\n    \n    style C fill:#fff2cc\n    style E fill:#ffe6cc\n    style F fill:#d5e8d4\n    style G fill:#f8cecc\n```\n\nThis diagram shows how Rust's type system makes error handling explicit and mandatory.\n\n## The Result<T, E> Type\n\nThe `Result` type is Rust's primary tool for recoverable errors. Here's how it works:\n\n```rust\n// Basic Result usage\nfn divide(a: f64, b: f64) -> Result<f64, String> {\n    if b == 0.0 {\n        Err(\"Cannot divide by zero\".to_string())\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    match divide(10.0, 2.0) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(error) => println!(\"Error: {}\", error),\n    }\n}\n```\n\nAs we discussed in [[rust-type-system-fundamentals]], the type system ensures you can't ignore potential errors.\n\n## The Option<T> Type\n\n`Option<T>` handles cases where a value might be absent:\n\n```rust\nfn find_user(id: u32) -> Option<User> {\n    // Simulate database lookup\n    if id == 1 {\n        Some(User { \n            id, \n            name: \"Alice\".to_string() \n        })\n    } else {\n        None\n    }\n}\n\nfn main() {\n    match find_user(1) {\n        Some(user) => println!(\"Found user: {}\", user.name),\n        None => println!(\"User not found\"),\n    }\n}\n```\n\n## Error Propagation Patterns\n\nRust provides several patterns for propagating errors through your call stack:\n\n```mermaid\nsequenceDiagram\n    participant Main\n    participant FunctionA\n    participant FunctionB\n    participant FunctionC\n    \n    Main->>FunctionA: Call\n    FunctionA->>FunctionB: Call\n    FunctionB->>FunctionC: Call\n    \n    alt Success Path\n        FunctionC-->>FunctionB: Ok(value)\n        FunctionB-->>FunctionA: Ok(processed)\n        FunctionA-->>Main: Ok(final)\n    else Error Path\n        FunctionC-->>FunctionB: Err(error)\n        FunctionB-->>FunctionA: Err(error) [? operator]\n        FunctionA-->>Main: Err(error) [? operator]\n    end\n```\n\n### The ? Operator\n\nThe `?` operator is Rust's primary tool for error propagation:\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_file_contents(path: &str) -> Result<String, io::Error> {\n    let mut file = File::open(path)?; // Propagates error if file doesn't exist\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?; // Propagates error if read fails\n    Ok(contents)\n}\n\n// Equivalent without ? operator (more verbose)\nfn read_file_contents_verbose(path: &str) -> Result<String, io::Error> {\n    let mut file = match File::open(path) {\n        Ok(file) => file,\n        Err(error) => return Err(error),\n    };\n    \n    let mut contents = String::new();\n    match file.read_to_string(&mut contents) {\n        Ok(_) => Ok(contents),\n        Err(error) => Err(error),\n    }\n}\n```\n\n## Custom Error Types\n\nFor complex applications, you'll want to create custom error types. Here's a comprehensive approach:\n\n```rust\nuse std::fmt;\nuse std::error::Error;\n\n#[derive(Debug)]\nenum AppError {\n    Io(std::io::Error),\n    Parse(std::num::ParseIntError),\n    Custom(String),\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            AppError::Io(err) => write!(f, \"IO error: {}\", err),\n            AppError::Parse(err) => write!(f, \"Parse error: {}\", err),\n            AppError::Custom(msg) => write!(f, \"Application error: {}\", msg),\n        }\n    }\n}\n\nimpl Error for AppError {\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n        match self {\n            AppError::Io(err) => Some(err),\n            AppError::Parse(err) => Some(err),\n            AppError::Custom(_) => None,\n        }\n    }\n}\n\n// Implement From for automatic conversion\nimpl From<std::io::Error> for AppError {\n    fn from(error: std::io::Error) -> Self {\n        AppError::Io(error)\n    }\n}\n\nimpl From<std::num::ParseIntError> for AppError {\n    fn from(error: std::num::ParseIntError) -> Self {\n        AppError::Parse(error)\n    }\n}\n```\n\nThis pattern allows you to use the `?` operator with different error types seamlessly.\n\n## Error Handling Strategies\n\nHere are the main strategies for handling errors in Rust:\n\n```mermaid\nclassDiagram\n    class ErrorStrategy {\n        <<enumeration>>\n    }\n    \n    class Panic {\n        +unwrap()\n        +expect()\n        +panic!()\n    }\n    \n    class Propagate {\n        +? operator\n        +try_into()\n        +Result chains\n    }\n    \n    class Handle {\n        +match\n        +if let\n        +unwrap_or()\n    }\n    \n    class Transform {\n        +map()\n        +map_err()\n        +and_then()\n    }\n    \n    ErrorStrategy --> Panic : Unrecoverable\n    ErrorStrategy --> Propagate : Let caller decide\n    ErrorStrategy --> Handle : Recover locally\n    ErrorStrategy --> Transform : Convert errors\n```\n\n### Strategy 1: Panic for Unrecoverable Errors\n\n```rust\nfn main() {\n    let config = std::fs::read_to_string(\"config.toml\")\n        .expect(\"Config file is required for application to run\");\n    \n    // If config file doesn't exist, the application should crash\n    println!(\"Config loaded: {}\", config);\n}\n```\n\n### Strategy 2: Graceful Error Handling\n\n```rust\nfn process_user_input(input: &str) -> Result<i32, AppError> {\n    let number: i32 = input.trim().parse()?;\n    \n    if number < 0 {\n        return Err(AppError::Custom(\"Number must be positive\".to_string()));\n    }\n    \n    Ok(number * 2)\n}\n\nfn main() {\n    match process_user_input(\"42\") {\n        Ok(result) => println!(\"Processed: {}\", result),\n        Err(error) => {\n            eprintln!(\"Error processing input: {}\", error);\n            // Could log, retry, or provide default value\n        }\n    }\n}\n```\n\n### Strategy 3: Chaining Operations\n\n```rust\nfn process_data(data: &str) -> Result<String, AppError> {\n    data.trim()\n        .parse::<i32>()?                    // Parse to integer\n        .checked_mul(2)                     // Safe multiplication\n        .ok_or_else(|| AppError::Custom(\"Overflow\".to_string()))?\n        .to_string()                        // Convert back to string\n        .chars()\n        .rev()\n        .collect::<String>()                // Reverse the string\n        .parse::<i32>()                     // Parse reversed string\n        .map(|n| format!(\"Final: {}\", n))   // Format result\n        .map_err(|e| e.into())              // Convert error type\n}\n```\n\n## Advanced Error Handling Patterns\n\n### Using the `anyhow` Crate\n\nFor applications (not libraries), consider using the `anyhow` crate for simpler error handling:\n\n```rust\nuse anyhow::{Context, Result};\n\nfn complex_operation() -> Result<String> {\n    let file_content = std::fs::read_to_string(\"data.txt\")\n        .context(\"Failed to read data file\")?;\n    \n    let parsed_number: i32 = file_content.trim().parse()\n        .context(\"File content is not a valid number\")?;\n    \n    if parsed_number < 0 {\n        anyhow::bail!(\"Number must be positive, got: {}\", parsed_number);\n    }\n    \n    Ok(format!(\"Processed: {}\", parsed_number * 2))\n}\n```\n\n### Error Recovery Patterns\n\nSometimes you want to try multiple approaches before giving up:\n\n```rust\nfn try_multiple_sources() -> Result<String, AppError> {\n    // Try primary source\n    if let Ok(data) = read_from_primary() {\n        return Ok(data);\n    }\n    \n    // Try backup source\n    if let Ok(data) = read_from_backup() {\n        return Ok(data);\n    }\n    \n    // Try default source\n    read_from_default()\n        .or_else(|_| Ok(\"Default value\".to_string()))\n}\n\nfn read_from_primary() -> Result<String, AppError> {\n    std::fs::read_to_string(\"primary.txt\").map_err(Into::into)\n}\n\nfn read_from_backup() -> Result<String, AppError> {\n    std::fs::read_to_string(\"backup.txt\").map_err(Into::into)\n}\n\nfn read_from_default() -> Result<String, AppError> {\n    std::fs::read_to_string(\"default.txt\").map_err(Into::into)\n}\n```\n\n## Error Handling in Async Code\n\nWhen working with async code, error handling patterns remain similar but with some considerations for [[async-rust-fundamentals]]:\n\n```rust\nuse tokio;\n\nasync fn fetch_user_data(id: u32) -> Result<User, AppError> {\n    let response = reqwest::get(&format!(\"https://api.example.com/users/{}\", id))\n        .await\n        .context(\"Failed to make HTTP request\")?;\n    \n    if !response.status().is_success() {\n        return Err(AppError::Custom(format!(\n            \"HTTP error: {}\", response.status()\n        )));\n    }\n    \n    let user: User = response.json()\n        .await\n        .context(\"Failed to parse JSON response\")?;\n    \n    Ok(user)\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), AppError> {\n    match fetch_user_data(1).await {\n        Ok(user) => println!(\"User: {:?}\", user),\n        Err(error) => {\n            eprintln!(\"Failed to fetch user: {}\", error);\n            // Could implement retry logic here\n        }\n    }\n    Ok(())\n}\n```\n\n## Testing Error Conditions\n\nTesting error paths is crucial for robust applications:\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_divide_by_zero() {\n        let result = divide(10.0, 0.0);\n        assert!(result.is_err());\n        \n        if let Err(error) = result {\n            assert_eq!(error, \"Cannot divide by zero\");\n        }\n    }\n\n    #[test]\n    fn test_successful_division() {\n        let result = divide(10.0, 2.0);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 5.0);\n    }\n\n    #[test]\n    fn test_error_propagation() {\n        // Test that errors bubble up correctly\n        let result = process_user_input(\"not_a_number\");\n        assert!(result.is_err());\n        \n        match result {\n            Err(AppError::Parse(_)) => {}, // Expected\n            _ => panic!(\"Expected parse error\"),\n        }\n    }\n}\n```\n\n## Performance Considerations\n\nRust's error handling is zero-cost when no errors occur[^2]. The `Result` type is optimized and doesn't allocate heap memory:\n\n```mermaid\ngraph LR\n    A[Success Path] --> B[No Allocation]\n    A --> C[Register-based]\n    A --> D[Zero Runtime Cost]\n    \n    E[Error Path] --> F[Stack Allocation]\n    E --> G[Minimal Overhead]\n    E --> H[No Exceptions]\n    \n    style B fill:#d5e8d4\n    style C fill:#d5e8d4\n    style D fill:#d5e8d4\n    style F fill:#fff2cc\n    style G fill:#fff2cc\n    style H fill:#fff2cc\n```\n\nHere's a performance comparison:\n\n```rust\nuse std::time::Instant;\n\nfn benchmark_error_handling() {\n    let start = Instant::now();\n    \n    // Success case - should be extremely fast\n    for i in 0..1_000_000 {\n        let result: Result<i32, &str> = Ok(i);\n        match result {\n            Ok(val) => { let _ = val * 2; },\n            Err(_) => {},\n        }\n    }\n    \n    println!(\"Success path: {:?}\", start.elapsed());\n    \n    let start = Instant::now();\n    \n    // Error case - still fast, no exceptions\n    for i in 0..1_000_000 {\n        let result: Result<i32, &str> = Err(\"error\");\n        match result {\n            Ok(_) => {},\n            Err(_) => { /* handle error */ },\n        }\n    }\n    \n    println!(\"Error path: {:?}\", start.elapsed());\n}\n```\n\n## Best Practices Summary\n\n1. **Use `Result<T, E>` for recoverable errors**\n2. **Use `Option<T>` for optional values**\n3. **Create custom error types for complex applications**\n4. **Use the `?` operator for error propagation**\n5. **Prefer explicit error handling over panicking**\n6. **Test both success and error paths**\n7. **Consider using `anyhow` for application error handling**\n8. **Use `thiserror` for library error types**\n\n## Common Pitfalls\n\n### Pitfall 1: Overusing `unwrap()`\n\n```rust\n// ❌ Bad: Will panic if file doesn't exist\nlet content = std::fs::read_to_string(\"file.txt\").unwrap();\n\n// ✅ Good: Handle the error appropriately  \nlet content = match std::fs::read_to_string(\"file.txt\") {\n    Ok(content) => content,\n    Err(error) => {\n        eprintln!(\"Failed to read file: {}\", error);\n        return;\n    }\n};\n```\n\n### Pitfall 2: Ignoring Error Context\n\n```rust\n// ❌ Bad: Loses error context\nfn process_file(path: &str) -> Result<String, Box<dyn std::error::Error>> {\n    let content = std::fs::read_to_string(path)?;\n    let number: i32 = content.trim().parse()?;\n    Ok(format!(\"Number: {}\", number))\n}\n\n// ✅ Good: Preserves error context\nfn process_file_better(path: &str) -> Result<String, AppError> {\n    let content = std::fs::read_to_string(path)\n        .map_err(|e| AppError::Io(e))?;\n    let number: i32 = content.trim().parse()\n        .map_err(|e| AppError::Parse(e))?;\n    Ok(format!(\"Number: {}\", number))\n}\n```\n\n## Conclusion\n\nRust's error handling system might seem verbose at first, but it provides several key benefits:\n\n- **Explicit**: Errors are visible in function signatures\n- **Safe**: Can't accidentally ignore errors\n- **Fast**: Zero-cost when no errors occur\n- **Composable**: Easy to chain and transform errors\n\nBy mastering these patterns, you'll write more robust and maintainable Rust code. For more advanced patterns, see [[advanced-rust-error-handling]] and [[rust-error-handling-async]].\n\nThe key is to embrace Rust's philosophy: make errors explicit, handle them appropriately, and let the type system guide you toward robust code.\n\n---\n\n### References\n\n[^1]: Unlike languages with exceptions (Java, C#, Python), Rust makes error handling explicit through the type system. This prevents the common issue of unhandled exceptions causing runtime crashes.\n\n[^2]: Rust's `Result<T, E>` is implemented as a tagged union that's optimized by LLVM. In the success case, it's essentially a direct value with no additional overhead compared to languages with exceptions.",
    "contentHtml": "<p>Error handling in Rust is fundamentally different from other languages. Instead of exceptions, Rust uses types like <code>Result&lt;T, E&gt;</code> and <code>Option&lt;T&gt;</code> to represent potential failures. This approach makes errors explicit and forces developers to handle them properly[^1].</p>\n<h2>The Error Handling Philosophy</h2>\n<p>Rust&#39;s approach to error handling is based on making errors visible in the type system:</p>\n<pre><code class=\"language-mermaid\">graph TD\n    A[Function Call] --&gt; B{Can Fail?}\n    B --&gt;|Yes| C[Result&lt;T, E&gt;]\n    B --&gt;|No| D[Direct Value T]\n    C --&gt; E{Handle Error}\n    E --&gt;|Success| F[Extract T]\n    E --&gt;|Failure| G[Handle E]\n    \n    style C fill:#fff2cc\n    style E fill:#ffe6cc\n    style F fill:#d5e8d4\n    style G fill:#f8cecc\n</code></pre>\n<p>This diagram shows how Rust&#39;s type system makes error handling explicit and mandatory.</p>\n<h2>The Result&lt;T, E&gt; Type</h2>\n<p>The <code>Result</code> type is Rust&#39;s primary tool for recoverable errors. Here&#39;s how it works:</p>\n<pre><code class=\"language-rust\">// Basic Result usage\nfn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {\n    if b == 0.0 {\n        Err(&quot;Cannot divide by zero&quot;.to_string())\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn main() {\n    match divide(10.0, 2.0) {\n        Ok(result) =&gt; println!(&quot;Result: {}&quot;, result),\n        Err(error) =&gt; println!(&quot;Error: {}&quot;, error),\n    }\n}\n</code></pre>\n<p>As we discussed in [[rust-type-system-fundamentals]], the type system ensures you can&#39;t ignore potential errors.</p>\n<h2>The Option<T> Type</h2>\n<p><code>Option&lt;T&gt;</code> handles cases where a value might be absent:</p>\n<pre><code class=\"language-rust\">fn find_user(id: u32) -&gt; Option&lt;User&gt; {\n    // Simulate database lookup\n    if id == 1 {\n        Some(User { \n            id, \n            name: &quot;Alice&quot;.to_string() \n        })\n    } else {\n        None\n    }\n}\n\nfn main() {\n    match find_user(1) {\n        Some(user) =&gt; println!(&quot;Found user: {}&quot;, user.name),\n        None =&gt; println!(&quot;User not found&quot;),\n    }\n}\n</code></pre>\n<h2>Error Propagation Patterns</h2>\n<p>Rust provides several patterns for propagating errors through your call stack:</p>\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant Main\n    participant FunctionA\n    participant FunctionB\n    participant FunctionC\n    \n    Main-&gt;&gt;FunctionA: Call\n    FunctionA-&gt;&gt;FunctionB: Call\n    FunctionB-&gt;&gt;FunctionC: Call\n    \n    alt Success Path\n        FunctionC--&gt;&gt;FunctionB: Ok(value)\n        FunctionB--&gt;&gt;FunctionA: Ok(processed)\n        FunctionA--&gt;&gt;Main: Ok(final)\n    else Error Path\n        FunctionC--&gt;&gt;FunctionB: Err(error)\n        FunctionB--&gt;&gt;FunctionA: Err(error) [? operator]\n        FunctionA--&gt;&gt;Main: Err(error) [? operator]\n    end\n</code></pre>\n<h3>The ? Operator</h3>\n<p>The <code>?</code> operator is Rust&#39;s primary tool for error propagation:</p>\n<pre><code class=\"language-rust\">use std::fs::File;\nuse std::io::{self, Read};\n\nfn read_file_contents(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {\n    let mut file = File::open(path)?; // Propagates error if file doesn&#39;t exist\n    let mut contents = String::new();\n    file.read_to_string(&amp;mut contents)?; // Propagates error if read fails\n    Ok(contents)\n}\n\n// Equivalent without ? operator (more verbose)\nfn read_file_contents_verbose(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {\n    let mut file = match File::open(path) {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; return Err(error),\n    };\n    \n    let mut contents = String::new();\n    match file.read_to_string(&amp;mut contents) {\n        Ok(_) =&gt; Ok(contents),\n        Err(error) =&gt; Err(error),\n    }\n}\n</code></pre>\n<h2>Custom Error Types</h2>\n<p>For complex applications, you&#39;ll want to create custom error types. Here&#39;s a comprehensive approach:</p>\n<pre><code class=\"language-rust\">use std::fmt;\nuse std::error::Error;\n\n#[derive(Debug)]\nenum AppError {\n    Io(std::io::Error),\n    Parse(std::num::ParseIntError),\n    Custom(String),\n}\n\nimpl fmt::Display for AppError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        match self {\n            AppError::Io(err) =&gt; write!(f, &quot;IO error: {}&quot;, err),\n            AppError::Parse(err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),\n            AppError::Custom(msg) =&gt; write!(f, &quot;Application error: {}&quot;, msg),\n        }\n    }\n}\n\nimpl Error for AppError {\n    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + &#39;static)&gt; {\n        match self {\n            AppError::Io(err) =&gt; Some(err),\n            AppError::Parse(err) =&gt; Some(err),\n            AppError::Custom(_) =&gt; None,\n        }\n    }\n}\n\n// Implement From for automatic conversion\nimpl From&lt;std::io::Error&gt; for AppError {\n    fn from(error: std::io::Error) -&gt; Self {\n        AppError::Io(error)\n    }\n}\n\nimpl From&lt;std::num::ParseIntError&gt; for AppError {\n    fn from(error: std::num::ParseIntError) -&gt; Self {\n        AppError::Parse(error)\n    }\n}\n</code></pre>\n<p>This pattern allows you to use the <code>?</code> operator with different error types seamlessly.</p>\n<h2>Error Handling Strategies</h2>\n<p>Here are the main strategies for handling errors in Rust:</p>\n<pre><code class=\"language-mermaid\">classDiagram\n    class ErrorStrategy {\n        &lt;&lt;enumeration&gt;&gt;\n    }\n    \n    class Panic {\n        +unwrap()\n        +expect()\n        +panic!()\n    }\n    \n    class Propagate {\n        +? operator\n        +try_into()\n        +Result chains\n    }\n    \n    class Handle {\n        +match\n        +if let\n        +unwrap_or()\n    }\n    \n    class Transform {\n        +map()\n        +map_err()\n        +and_then()\n    }\n    \n    ErrorStrategy --&gt; Panic : Unrecoverable\n    ErrorStrategy --&gt; Propagate : Let caller decide\n    ErrorStrategy --&gt; Handle : Recover locally\n    ErrorStrategy --&gt; Transform : Convert errors\n</code></pre>\n<h3>Strategy 1: Panic for Unrecoverable Errors</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let config = std::fs::read_to_string(&quot;config.toml&quot;)\n        .expect(&quot;Config file is required for application to run&quot;);\n    \n    // If config file doesn&#39;t exist, the application should crash\n    println!(&quot;Config loaded: {}&quot;, config);\n}\n</code></pre>\n<h3>Strategy 2: Graceful Error Handling</h3>\n<pre><code class=\"language-rust\">fn process_user_input(input: &amp;str) -&gt; Result&lt;i32, AppError&gt; {\n    let number: i32 = input.trim().parse()?;\n    \n    if number &lt; 0 {\n        return Err(AppError::Custom(&quot;Number must be positive&quot;.to_string()));\n    }\n    \n    Ok(number * 2)\n}\n\nfn main() {\n    match process_user_input(&quot;42&quot;) {\n        Ok(result) =&gt; println!(&quot;Processed: {}&quot;, result),\n        Err(error) =&gt; {\n            eprintln!(&quot;Error processing input: {}&quot;, error);\n            // Could log, retry, or provide default value\n        }\n    }\n}\n</code></pre>\n<h3>Strategy 3: Chaining Operations</h3>\n<pre><code class=\"language-rust\">fn process_data(data: &amp;str) -&gt; Result&lt;String, AppError&gt; {\n    data.trim()\n        .parse::&lt;i32&gt;()?                    // Parse to integer\n        .checked_mul(2)                     // Safe multiplication\n        .ok_or_else(|| AppError::Custom(&quot;Overflow&quot;.to_string()))?\n        .to_string()                        // Convert back to string\n        .chars()\n        .rev()\n        .collect::&lt;String&gt;()                // Reverse the string\n        .parse::&lt;i32&gt;()                     // Parse reversed string\n        .map(|n| format!(&quot;Final: {}&quot;, n))   // Format result\n        .map_err(|e| e.into())              // Convert error type\n}\n</code></pre>\n<h2>Advanced Error Handling Patterns</h2>\n<h3>Using the <code>anyhow</code> Crate</h3>\n<p>For applications (not libraries), consider using the <code>anyhow</code> crate for simpler error handling:</p>\n<pre><code class=\"language-rust\">use anyhow::{Context, Result};\n\nfn complex_operation() -&gt; Result&lt;String&gt; {\n    let file_content = std::fs::read_to_string(&quot;data.txt&quot;)\n        .context(&quot;Failed to read data file&quot;)?;\n    \n    let parsed_number: i32 = file_content.trim().parse()\n        .context(&quot;File content is not a valid number&quot;)?;\n    \n    if parsed_number &lt; 0 {\n        anyhow::bail!(&quot;Number must be positive, got: {}&quot;, parsed_number);\n    }\n    \n    Ok(format!(&quot;Processed: {}&quot;, parsed_number * 2))\n}\n</code></pre>\n<h3>Error Recovery Patterns</h3>\n<p>Sometimes you want to try multiple approaches before giving up:</p>\n<pre><code class=\"language-rust\">fn try_multiple_sources() -&gt; Result&lt;String, AppError&gt; {\n    // Try primary source\n    if let Ok(data) = read_from_primary() {\n        return Ok(data);\n    }\n    \n    // Try backup source\n    if let Ok(data) = read_from_backup() {\n        return Ok(data);\n    }\n    \n    // Try default source\n    read_from_default()\n        .or_else(|_| Ok(&quot;Default value&quot;.to_string()))\n}\n\nfn read_from_primary() -&gt; Result&lt;String, AppError&gt; {\n    std::fs::read_to_string(&quot;primary.txt&quot;).map_err(Into::into)\n}\n\nfn read_from_backup() -&gt; Result&lt;String, AppError&gt; {\n    std::fs::read_to_string(&quot;backup.txt&quot;).map_err(Into::into)\n}\n\nfn read_from_default() -&gt; Result&lt;String, AppError&gt; {\n    std::fs::read_to_string(&quot;default.txt&quot;).map_err(Into::into)\n}\n</code></pre>\n<h2>Error Handling in Async Code</h2>\n<p>When working with async code, error handling patterns remain similar but with some considerations for [[async-rust-fundamentals]]:</p>\n<pre><code class=\"language-rust\">use tokio;\n\nasync fn fetch_user_data(id: u32) -&gt; Result&lt;User, AppError&gt; {\n    let response = reqwest::get(&amp;format!(&quot;https://api.example.com/users/{}&quot;, id))\n        .await\n        .context(&quot;Failed to make HTTP request&quot;)?;\n    \n    if !response.status().is_success() {\n        return Err(AppError::Custom(format!(\n            &quot;HTTP error: {}&quot;, response.status()\n        )));\n    }\n    \n    let user: User = response.json()\n        .await\n        .context(&quot;Failed to parse JSON response&quot;)?;\n    \n    Ok(user)\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), AppError&gt; {\n    match fetch_user_data(1).await {\n        Ok(user) =&gt; println!(&quot;User: {:?}&quot;, user),\n        Err(error) =&gt; {\n            eprintln!(&quot;Failed to fetch user: {}&quot;, error);\n            // Could implement retry logic here\n        }\n    }\n    Ok(())\n}\n</code></pre>\n<h2>Testing Error Conditions</h2>\n<p>Testing error paths is crucial for robust applications:</p>\n<pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_divide_by_zero() {\n        let result = divide(10.0, 0.0);\n        assert!(result.is_err());\n        \n        if let Err(error) = result {\n            assert_eq!(error, &quot;Cannot divide by zero&quot;);\n        }\n    }\n\n    #[test]\n    fn test_successful_division() {\n        let result = divide(10.0, 2.0);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 5.0);\n    }\n\n    #[test]\n    fn test_error_propagation() {\n        // Test that errors bubble up correctly\n        let result = process_user_input(&quot;not_a_number&quot;);\n        assert!(result.is_err());\n        \n        match result {\n            Err(AppError::Parse(_)) =&gt; {}, // Expected\n            _ =&gt; panic!(&quot;Expected parse error&quot;),\n        }\n    }\n}\n</code></pre>\n<h2>Performance Considerations</h2>\n<p>Rust&#39;s error handling is zero-cost when no errors occur[^2]. The <code>Result</code> type is optimized and doesn&#39;t allocate heap memory:</p>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Success Path] --&gt; B[No Allocation]\n    A --&gt; C[Register-based]\n    A --&gt; D[Zero Runtime Cost]\n    \n    E[Error Path] --&gt; F[Stack Allocation]\n    E --&gt; G[Minimal Overhead]\n    E --&gt; H[No Exceptions]\n    \n    style B fill:#d5e8d4\n    style C fill:#d5e8d4\n    style D fill:#d5e8d4\n    style F fill:#fff2cc\n    style G fill:#fff2cc\n    style H fill:#fff2cc\n</code></pre>\n<p>Here&#39;s a performance comparison:</p>\n<pre><code class=\"language-rust\">use std::time::Instant;\n\nfn benchmark_error_handling() {\n    let start = Instant::now();\n    \n    // Success case - should be extremely fast\n    for i in 0..1_000_000 {\n        let result: Result&lt;i32, &amp;str&gt; = Ok(i);\n        match result {\n            Ok(val) =&gt; { let _ = val * 2; },\n            Err(_) =&gt; {},\n        }\n    }\n    \n    println!(&quot;Success path: {:?}&quot;, start.elapsed());\n    \n    let start = Instant::now();\n    \n    // Error case - still fast, no exceptions\n    for i in 0..1_000_000 {\n        let result: Result&lt;i32, &amp;str&gt; = Err(&quot;error&quot;);\n        match result {\n            Ok(_) =&gt; {},\n            Err(_) =&gt; { /* handle error */ },\n        }\n    }\n    \n    println!(&quot;Error path: {:?}&quot;, start.elapsed());\n}\n</code></pre>\n<h2>Best Practices Summary</h2>\n<ol>\n<li><strong>Use <code>Result&lt;T, E&gt;</code> for recoverable errors</strong></li>\n<li><strong>Use <code>Option&lt;T&gt;</code> for optional values</strong></li>\n<li><strong>Create custom error types for complex applications</strong></li>\n<li><strong>Use the <code>?</code> operator for error propagation</strong></li>\n<li><strong>Prefer explicit error handling over panicking</strong></li>\n<li><strong>Test both success and error paths</strong></li>\n<li><strong>Consider using <code>anyhow</code> for application error handling</strong></li>\n<li><strong>Use <code>thiserror</code> for library error types</strong></li>\n</ol>\n<h2>Common Pitfalls</h2>\n<h3>Pitfall 1: Overusing <code>unwrap()</code></h3>\n<pre><code class=\"language-rust\">// ❌ Bad: Will panic if file doesn&#39;t exist\nlet content = std::fs::read_to_string(&quot;file.txt&quot;).unwrap();\n\n// ✅ Good: Handle the error appropriately  \nlet content = match std::fs::read_to_string(&quot;file.txt&quot;) {\n    Ok(content) =&gt; content,\n    Err(error) =&gt; {\n        eprintln!(&quot;Failed to read file: {}&quot;, error);\n        return;\n    }\n};\n</code></pre>\n<h3>Pitfall 2: Ignoring Error Context</h3>\n<pre><code class=\"language-rust\">// ❌ Bad: Loses error context\nfn process_file(path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {\n    let content = std::fs::read_to_string(path)?;\n    let number: i32 = content.trim().parse()?;\n    Ok(format!(&quot;Number: {}&quot;, number))\n}\n\n// ✅ Good: Preserves error context\nfn process_file_better(path: &amp;str) -&gt; Result&lt;String, AppError&gt; {\n    let content = std::fs::read_to_string(path)\n        .map_err(|e| AppError::Io(e))?;\n    let number: i32 = content.trim().parse()\n        .map_err(|e| AppError::Parse(e))?;\n    Ok(format!(&quot;Number: {}&quot;, number))\n}\n</code></pre>\n<h2>Conclusion</h2>\n<p>Rust&#39;s error handling system might seem verbose at first, but it provides several key benefits:</p>\n<ul>\n<li><strong>Explicit</strong>: Errors are visible in function signatures</li>\n<li><strong>Safe</strong>: Can&#39;t accidentally ignore errors</li>\n<li><strong>Fast</strong>: Zero-cost when no errors occur</li>\n<li><strong>Composable</strong>: Easy to chain and transform errors</li>\n</ul>\n<p>By mastering these patterns, you&#39;ll write more robust and maintainable Rust code. For more advanced patterns, see [[advanced-rust-error-handling]] and [[rust-error-handling-async]].</p>\n<p>The key is to embrace Rust&#39;s philosophy: make errors explicit, handle them appropriately, and let the type system guide you toward robust code.</p>\n<hr>\n<h3>References</h3>\n<p>[^1]: Unlike languages with exceptions (Java, C#, Python), Rust makes error handling explicit through the type system. This prevents the common issue of unhandled exceptions causing runtime crashes.</p>\n<p>[^2]: Rust&#39;s <code>Result&lt;T, E&gt;</code> is implemented as a tagged union that&#39;s optimized by LLVM. In the success case, it&#39;s essentially a direct value with no additional overhead compared to languages with exceptions.</p>\n",
    "author": "Mayorana",
    "category": "rust-fundamentals",
    "tags": [
      "rust",
      "error-handling",
      "result",
      "option",
      "best-practices"
    ],
    "readingTime": "9 min",
    "locale": "fr",
    "seo": {
      "title": "Complete Guide to Rust Error Handling with Visual Examples",
      "description": "Master Rust's error handling with Result, Option, and custom errors. Includes visual diagrams, code examples with copy functionality, and cross-references to related concepts.",
      "keywords": [
        "rust",
        "error-handling",
        "result",
        "option",
        "best-practices"
      ]
    },
    "headings": [
      {
        "id": "the-error-handling-philosophy",
        "text": "The Error Handling Philosophy",
        "level": 2
      },
      {
        "id": "the-resultlesst-egreater-type",
        "text": "The Result<T, E> Type",
        "level": 2
      },
      {
        "id": "the-optionlesstgreater-type",
        "text": "The Option<T> Type",
        "level": 2
      },
      {
        "id": "error-propagation-patterns",
        "text": "Error Propagation Patterns",
        "level": 2
      },
      {
        "id": "the-operator",
        "text": "The ? Operator",
        "level": 3
      },
      {
        "id": "custom-error-types",
        "text": "Custom Error Types",
        "level": 2
      },
      {
        "id": "error-handling-strategies",
        "text": "Error Handling Strategies",
        "level": 2
      },
      {
        "id": "strategy-1-panic-for-unrecoverable-errors",
        "text": "Strategy 1: Panic for Unrecoverable Errors",
        "level": 3
      },
      {
        "id": "strategy-2-graceful-error-handling",
        "text": "Strategy 2: Graceful Error Handling",
        "level": 3
      },
      {
        "id": "strategy-3-chaining-operations",
        "text": "Strategy 3: Chaining Operations",
        "level": 3
      },
      {
        "id": "advanced-error-handling-patterns",
        "text": "Advanced Error Handling Patterns",
        "level": 2
      },
      {
        "id": "using-the-anyhow-crate",
        "text": "Using the `anyhow` Crate",
        "level": 3
      },
      {
        "id": "error-recovery-patterns",
        "text": "Error Recovery Patterns",
        "level": 3
      },
      {
        "id": "error-handling-in-async-code",
        "text": "Error Handling in Async Code",
        "level": 2
      },
      {
        "id": "testing-error-conditions",
        "text": "Testing Error Conditions",
        "level": 2
      },
      {
        "id": "performance-considerations",
        "text": "Performance Considerations",
        "level": 2
      },
      {
        "id": "best-practices-summary",
        "text": "Best Practices Summary",
        "level": 2
      },
      {
        "id": "common-pitfalls",
        "text": "Common Pitfalls",
        "level": 2
      },
      {
        "id": "pitfall-1-overusing-unwrap",
        "text": "Pitfall 1: Overusing `unwrap()`",
        "level": 3
      },
      {
        "id": "pitfall-2-ignoring-error-context",
        "text": "Pitfall 2: Ignoring Error Context",
        "level": 3
      },
      {
        "id": "conclusion",
        "text": "Conclusion",
        "level": 2
      },
      {
        "id": "references",
        "text": "References",
        "level": 3
      }
    ]
  }
]