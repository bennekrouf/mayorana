[
  {
    "id": "getting-started-with-rust-fr",
    "slug": "getting-started-with-rust-fr",
    "title": "Débuter avec Rust",
    "date": "2025-04-15",
    "excerpt": "Introduction à Rust, couvrant l'installation, la syntaxe de base, et ton premier projet.",
    "content": "Rust gagne considérablement en popularité parmi les développeurs pour son focus sur la performance, la memory safety, et la concurrence. Si tu es nouveau à Rust, ce guide t'aidera à débuter avec les bases.\n\n## Configuration de Ton Environnement\n\nD'abord, tu dois installer Rust. La façon la plus simple est d'utiliser rustup, l'installateur de toolchain Rust :\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\nCette commande téléchargera un script et démarrera le processus d'installation.\n\n### Vérification de l'Installation\n\nUne fois l'installation terminée, vérifie que tout fonctionne correctement :\n\n```bash\nrustc --version\ncargo --version\n```\n\nTu dois voir les numéros de version de Rust et Cargo s'afficher.\n\n### Configuration de l'Éditeur\n\nPour une meilleure expérience de développement, configure ton éditeur préféré :\n\n**VS Code :**\n- Installe l'extension \"rust-analyzer\"\n- Installe l'extension \"CodeLLDB\" pour le debugging\n\n**IntelliJ/CLion :**\n- Installe le plugin \"Rust\"\n\n**Vim/Neovim :**\n- Utilise rust.vim et coc-rust-analyzer\n\n## Ton Premier Programme Rust\n\nCréons un simple programme \"Hello, World!\". Créé un nouveau fichier appelé `hello.rs` avec le contenu suivant :\n\n```rust\nfn main() {\n    println!(\"Hello, World!\");\n}\n```\n\nPour compiler et exécuter ce programme, utilise les commandes suivantes :\n\n```bash\nrustc hello.rs\n./hello  # Sur Windows: hello.exe\n```\n\n### Anatomie du Programme\n\nAnalysons ce simple programme :\n\n```rust\nfn main() {           // Fonction principale - point d'entrée du programme\n    println!(         // Macro pour imprimer du texte\n        \"Hello, World!\" // String à imprimer\n    );                // Point-virgule requis pour terminer l'expression\n}\n```\n\n**Points importants :**\n- `fn main()` est la fonction principale, exécutée en premier\n- `println!` est une **macro** (note le `!`) qui imprime du texte\n- Les déclarations se terminent par un point-virgule `;`\n\n## Comprendre Cargo\n\nCargo est le système de build et gestionnaire de packages de Rust. Il gère de nombreuses tâches comme compilateur ton code, télécharger des libraries, et compilateur ces libraries.\n\n### Créer un Nouveau Projet\n\nPour créer un nouveau projet avec Cargo :\n\n```bash\ncargo new hello_cargo\ncd hello_cargo\n```\n\nCeci crée un nouveau répertoire appelé `hello_cargo` avec la structure suivante :\n\n```\nhello_cargo/\n├── Cargo.toml        # Métadonnées du projet et dépendances\n├── Cargo.lock        # Verrouillage des versions (généré automatiquement)\n├── .gitignore        # Fichier Git ignore\n└── src/\n    └── main.rs       # Code source principal\n```\n\n### Le Fichier Cargo.toml\n\nLe fichier `Cargo.toml` contient les métadonnées de ton projet :\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"        # Édition de Rust à utiliser\n\n[dependencies]\n# Les dépendances seront listées ici\n```\n\n### Commandes Cargo Essentielles\n\n```bash\ncargo build           # Compile le projet (debug mode)\ncargo build --release # Compile en mode optimisé (release)\ncargo run             # Compile et exécute le projet\ncargo check           # Vérifie que le code compile sans générer l'exécutable\ncargo clean           # Nettoie les fichiers de build\ncargo test            # Exécute les tests\ncargo doc             # Génère la documentation\n```\n\n### Exemple Pratique avec une Dépendance\n\nModifions notre projet pour utiliser une dépendance externe. Éditons `Cargo.toml` :\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nrand = \"0.8\"\n```\n\nMaintenant, modifions `src/main.rs` :\n\n```rust\nuse rand::Rng;  // Importer le trait Rng\n\nfn main() {\n    println!(\"Hello, World!\");\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    println!(\"Le nombre secret est : {}\", secret_number);\n}\n```\n\nExécute avec `cargo run` - Cargo téléchargera et compilera automatiquement la dépendance `rand`.\n\n## Concepts Clés de Rust\n\n### Variables et Mutabilité\n\nPar défaut, les variables en Rust sont **immutables** :\n\n```rust\nfn main() {\n    let x = 5;\n    println!(\"La valeur de x est : {}\", x);\n    \n    // x = 6; // ❌ ERREUR : cannot assign twice to immutable variable\n}\n```\n\nPour rendre une variable mutable, utilise le mot-clé `mut` :\n\n```rust\nfn main() {\n    let mut y = 5;\n    println!(\"La valeur de y est : {}\", y);\n    \n    y = 6; // ✅ OK : y est mutable\n    println!(\"La valeur de y est maintenant : {}\", y);\n}\n```\n\n### Constantes vs Variables\n\n```rust\nconst PI: f64 = 3.14159;  // Constante - toujours immutable\n\nfn main() {\n    let x = 5;        // Variable immutable\n    let mut y = 10;   // Variable mutable\n    \n    println!(\"PI = {}, x = {}, y = {}\", PI, x, y);\n}\n```\n\n### Shadowing (Masquage)\n\nRust permet de \"masquer\" une variable en déclarant une nouvelle variable avec le même nom :\n\n```rust\nfn main() {\n    let x = 5;\n    let x = x + 1;    // Nouveau x qui masque le précédent\n    let x = x * 2;    // Encore un nouveau x\n    \n    println!(\"La valeur de x est : {}\", x); // 12\n    \n    // On peut même changer le type\n    let spaces = \"   \";        // &str\n    let spaces = spaces.len(); // usize\n    println!(\"Nombre d'espaces : {}\", spaces);\n}\n```\n\n### Types de Données de Base\n\n```rust\nfn main() {\n    // Integers\n    let signed: i32 = -42;      // 32-bit signé\n    let unsigned: u32 = 42;     // 32-bit non-signé\n    \n    // Floats\n    let pi: f64 = 3.14159;      // 64-bit (default)\n    let e: f32 = 2.718;         // 32-bit\n    \n    // Boolean\n    let is_rust_awesome: bool = true;\n    \n    // Character (Unicode)\n    let heart: char = '💖';\n    \n    // String slice\n    let greeting: &str = \"Bonjour\";\n    \n    // String owned\n    let name: String = String::from(\"Rust\");\n    \n    println!(\"i32: {}, u32: {}, f64: {}, f32: {}\", signed, unsigned, pi, e);\n    println!(\"bool: {}, char: {}, &str: {}, String: {}\", \n             is_rust_awesome, heart, greeting, name);\n}\n```\n\n### Tuples et Arrays\n\n```rust\nfn main() {\n    // Tuple - types mixtes, taille fixe\n    let person: (String, i32, bool) = (String::from(\"Alice\"), 25, true);\n    let (name, age, is_student) = person; // Destructuring\n    \n    println!(\"{} a {} ans, étudiant: {}\", name, age, is_student);\n    \n    // Access par index\n    let coordinates = (3.0, 4.0);\n    println!(\"x: {}, y: {}\", coordinates.0, coordinates.1);\n    \n    // Array - même type, taille fixe\n    let numbers: [i32; 5] = [1, 2, 3, 4, 5];\n    let first = numbers[0];\n    let length = numbers.len();\n    \n    println!(\"Premier élément: {}, longueur: {}\", first, length);\n    \n    // Array avec valeur répétée\n    let zeros = [0; 10]; // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    println!(\"Array de zéros: {:?}\", zeros);\n}\n```\n\n## Ownership (Propriété)\n\nL'ownership est la fonctionnalité la plus unique de Rust et permet la memory safety sans garbage collection. Les règles principales sont :\n\n1. **Chaque valeur en Rust a une variable qui en est le propriétaire**\n2. **Il ne peut y avoir qu'un seul propriétaire à la fois**\n3. **Quand le propriétaire sort du scope, la valeur sera supprimée**\n\n### Exemple de Move\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1; // ✅ s1 est \"moved\" vers s2, s1 n'est plus valide\n    \n    // println!(\"{}\", s1); // ❌ ERREUR : borrow of moved value\n    println!(\"{}\", s2);     // ✅ OK\n}\n```\n\n### Clone pour Copier\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone(); // ✅ Copie profonde explicite\n    \n    println!(\"s1 = {}, s2 = {}\", s1, s2); // ✅ Les deux sont valides\n}\n```\n\n### Copy Types\n\nCertains types implémentent le trait `Copy` et sont copiés automatiquement :\n\n```rust\nfn main() {\n    let x = 5;       // i32 implémente Copy\n    let y = x;       // x est copié vers y\n    \n    println!(\"x = {}, y = {}\", x, y); // ✅ Les deux sont valides\n    \n    // Types qui implémentent Copy :\n    // - Tous les types entiers (i32, u32, etc.)\n    // - Types booléens (bool)\n    // - Types flottants (f32, f64)\n    // - Character (char)\n    // - Tuples contenant uniquement des types Copy\n}\n```\n\n### Ownership et Functions\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    \n    takes_ownership(s);              // s est moved dans la fonction\n    // println!(\"{}\", s);            // ❌ ERREUR : s n'est plus valide\n    \n    let x = 5;\n    makes_copy(x);                   // x est copié dans la fonction\n    println!(\"{}\", x);               // ✅ OK : x est encore valide\n}\n\nfn takes_ownership(some_string: String) { // some_string entre dans le scope\n    println!(\"{}\", some_string);\n} // some_string sort du scope et est supprimé\n\nfn makes_copy(some_integer: i32) { // some_integer entre dans le scope\n    println!(\"{}\", some_integer);\n} // some_integer sort du scope, mais rien de spécial ne se passe\n```\n\n### Références et Emprunts\n\nPour utiliser une valeur sans prendre l'ownership, utilise les **références** :\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    \n    let len = calculate_length(&s1); // Passer une référence\n    \n    println!(\"La longueur de '{}' est {}.\", s1, len); // s1 toujours valide\n}\n\nfn calculate_length(s: &String) -> usize { // s est une référence à String\n    s.len()\n} // s sort du scope, mais ne possède pas la donnée, rien n'est supprimé\n```\n\n### Références Mutables\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n    \n    change(&mut s); // Passer une référence mutable\n    \n    println!(\"{}\", s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n**Règles des références :**\n- Une seule référence mutable OU plusieurs références immutables\n- Les références doivent toujours être valides\n\n## Structures de Contrôle\n\n### Conditions avec if\n\n```rust\nfn main() {\n    let number = 6;\n    \n    if number % 4 == 0 {\n        println!(\"Le nombre est divisible par 4\");\n    } else if number % 3 == 0 {\n        println!(\"Le nombre est divisible par 3\");\n    } else if number % 2 == 0 {\n        println!(\"Le nombre est divisible par 2\");\n    } else {\n        println!(\"Le nombre n'est pas divisible par 4, 3, ou 2\");\n    }\n    \n    // if est une expression\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n    println!(\"La valeur du nombre est : {}\", number);\n}\n```\n\n### Boucles\n\n```rust\nfn main() {\n    // Boucle infinie\n    let mut counter = 0;\n    let result = loop {\n        counter += 1;\n        \n        if counter == 10 {\n            break counter * 2; // Retourner une valeur avec break\n        }\n    };\n    println!(\"Le résultat est {}\", result);\n    \n    // Boucle while\n    let mut number = 3;\n    while number != 0 {\n        println!(\"{}!\", number);\n        number -= 1;\n    }\n    println!(\"LIFTOFF!!!\");\n    \n    // Boucle for\n    let a = [10, 20, 30, 40, 50];\n    for element in a {\n        println!(\"La valeur est : {}\", element);\n    }\n    \n    // Range avec for\n    for number in (1..4).rev() {\n        println!(\"{}!\", number);\n    }\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n## Functions\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n    \n    another_function(5);\n    print_labeled_measurement(5, 'h');\n    \n    let x = plus_one(5);\n    println!(\"La valeur de x est : {}\", x);\n}\n\nfn another_function(x: i32) {\n    println!(\"La valeur de x est : {}\", x);\n}\n\nfn print_labeled_measurement(value: i32, unit_label: char) {\n    println!(\"La mesure est : {}{}\", value, unit_label);\n}\n\n// Function avec valeur de retour\nfn plus_one(x: i32) -> i32 {\n    x + 1 // Expression sans point-virgule = valeur de retour\n}\n\n// Avec return explicite\nfn minus_one(x: i32) -> i32 {\n    return x - 1; // return explicite avec point-virgule\n}\n```\n\n## Gestion d'Erreur de Base\n\n### Option\n\n```rust\nfn main() {\n    let some_number = Some(5);\n    let some_string = Some(\"a string\");\n    let absent_number: Option<i32> = None;\n    \n    // Pattern matching avec match\n    match some_number {\n        Some(value) => println!(\"La valeur est {}\", value),\n        None => println!(\"Aucune valeur\"),\n    }\n    \n    // Avec if let\n    if let Some(value) = some_number {\n        println!(\"La valeur est {}\", value);\n    }\n}\n```\n\n### Result\n\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    // Gestion d'erreur avec match\n    let file_result = File::open(\"hello.txt\");\n    \n    let _file = match file_result {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => {\n                println!(\"Fichier non trouvé !\");\n                return;\n            }\n            other_error => {\n                println!(\"Problème à l'ouverture du fichier : {:?}\", other_error);\n                return;\n            }\n        },\n    };\n    \n    // Avec unwrap_or_else\n    let _file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            println!(\"Création du fichier...\");\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Problème lors de la création du fichier : {:?}\", error);\n            })\n        } else {\n            panic!(\"Problème à l'ouverture du fichier : {:?}\", error);\n        }\n    });\n}\n```\n\n## Premier Projet Pratique : Jeu de Devinette\n\nCréons un jeu simple pour mettre en pratique ce que nous avons appris :\n\n```rust\nuse rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"Devine le nombre !\");\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    \n    loop {\n        println!(\"Saisie quelque chose.\");\n        \n        let mut guess = String::new();\n        \n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Échec de la lecture de la ligne\");\n            \n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => {\n                println!(\"Entre un nombre valide !\");\n                continue;\n            }\n        };\n        \n        println!(\"Tu as deviné : {}\", guess);\n        \n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Trop petit !\"),\n            Ordering::Greater => println!(\"Trop grand !\"),\n            Ordering::Equal => {\n                println!(\"Tu as gagné !\");\n                break;\n            }\n        }\n    }\n}\n```\n\nPour ce projet, ajoute dans ton `Cargo.toml` :\n\n```toml\n[dependencies]\nrand = \"0.8\"\n```\n\n## Outils Utiles\n\n### Formatage du Code\n\n```bash\ncargo fmt  # Formate automatiquement ton code\n```\n\n### Linting\n\n```bash\ncargo clippy  # Analyse statique pour améliorer ton code\n```\n\n### Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    \n    #[test]\n    #[should_panic]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n}\n```\n\nExécute avec `cargo test`.\n\n## Prochaines Étapes\n\nMaintenant que tu as les bases, Essaie de construire un petit projet pour pratiquer vos compétences. Voici quelques suggestions :\n\n### Projets Débutants\n1. **Calculatrice en ligne de commande**\n2. **Convertisseur de température**\n3. **Gestionnaire de liste de tâches simple**\n4. **Générateur de mots de passe**\n\n### Ressources d'Apprentissage\n\nLa documentation Rust est excellente pour approfondir vos connaissances :\n\n- [Le Livre Rust (The Rust Book)](https://doc.rust-lang.org/book/) - Guide complet et officiel\n- [Rust by Example](https://doc.rust-lang.org/rust-by-example/) - Apprendre par l'exemple\n- [Rustlings](https://github.com/rust-lang/rustlings) - Petits exercices pratiques\n- [Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/) - Recettes de code\n- [Comprehensive Rust](https://google.github.io/comprehensive-rust/) - Cours Google\n\n### Communauté\n\n- [Forum officiel Rust](https://users.rust-lang.org/)\n- [Reddit r/rust](https://www.reddit.com/r/rust/)\n- [Discord Rust Community](https://discord.gg/rust-lang-community)\n- [This Week in Rust](https://this-week-in-rust.org/) - Newsletter hebdomadaire\n\n### Concepts Avancés à Explorer Ensuite\n\n1. **Structs et Enums**\n2. **Pattern Matching avancé**\n3. **Traits et Generics**\n4. **Gestion des erreurs avancée**\n5. **Concurrence et parallélisme**\n6. **Macros**\n7. **Unsafe Rust**\n\nBon codage avec Rust ! 🦀\n\n---\n\n**Astuce :** N'hésite pas à expérimenter avec le code. Rust a un excellent compilateur qui te guidera avec des messages d'erreur très informatifs. Chaque erreur est une opportunité d'apprentissage !",
    "contentHtml": "<p>Rust gagne considérablement en popularité parmi les développeurs pour son focus sur la performance, la memory safety, et la concurrence. Si tu es nouveau à Rust, ce guide t&#39;aidera à débuter avec les bases.</p>\n<h2>Configuration de Ton Environnement</h2>\n<p>D&#39;abord, tu dois installer Rust. La façon la plus simple est d&#39;utiliser rustup, l&#39;installateur de toolchain Rust :</p>\n<pre><code class=\"language-bash\">curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>\n<p>Cette commande téléchargera un script et démarrera le processus d&#39;installation.</p>\n<h3>Vérification de l&#39;Installation</h3>\n<p>Une fois l&#39;installation terminée, vérifie que tout fonctionne correctement :</p>\n<pre><code class=\"language-bash\">rustc --version\ncargo --version\n</code></pre>\n<p>Tu dois voir les numéros de version de Rust et Cargo s&#39;afficher.</p>\n<h3>Configuration de l&#39;Éditeur</h3>\n<p>Pour une meilleure expérience de développement, configure ton éditeur préféré :</p>\n<p><strong>VS Code :</strong></p>\n<ul>\n<li>Installe l&#39;extension &quot;rust-analyzer&quot;</li>\n<li>Installe l&#39;extension &quot;CodeLLDB&quot; pour le debugging</li>\n</ul>\n<p><strong>IntelliJ/CLion :</strong></p>\n<ul>\n<li>Installe le plugin &quot;Rust&quot;</li>\n</ul>\n<p><strong>Vim/Neovim :</strong></p>\n<ul>\n<li>Utilise rust.vim et coc-rust-analyzer</li>\n</ul>\n<h2>Ton Premier Programme Rust</h2>\n<p>Créons un simple programme &quot;Hello, World!&quot;. Créé un nouveau fichier appelé <code>hello.rs</code> avec le contenu suivant :</p>\n<pre><code class=\"language-rust\">fn main() {\n    println!(&quot;Hello, World!&quot;);\n}\n</code></pre>\n<p>Pour compiler et exécuter ce programme, utilise les commandes suivantes :</p>\n<pre><code class=\"language-bash\">rustc hello.rs\n./hello  # Sur Windows: hello.exe\n</code></pre>\n<h3>Anatomie du Programme</h3>\n<p>Analysons ce simple programme :</p>\n<pre><code class=\"language-rust\">fn main() {           // Fonction principale - point d&#39;entrée du programme\n    println!(         // Macro pour imprimer du texte\n        &quot;Hello, World!&quot; // String à imprimer\n    );                // Point-virgule requis pour terminer l&#39;expression\n}\n</code></pre>\n<p><strong>Points importants :</strong></p>\n<ul>\n<li><code>fn main()</code> est la fonction principale, exécutée en premier</li>\n<li><code>println!</code> est une <strong>macro</strong> (note le <code>!</code>) qui imprime du texte</li>\n<li>Les déclarations se terminent par un point-virgule <code>;</code></li>\n</ul>\n<h2>Comprendre Cargo</h2>\n<p>Cargo est le système de build et gestionnaire de packages de Rust. Il gère de nombreuses tâches comme compilateur ton code, télécharger des libraries, et compilateur ces libraries.</p>\n<h3>Créer un Nouveau Projet</h3>\n<p>Pour créer un nouveau projet avec Cargo :</p>\n<pre><code class=\"language-bash\">cargo new hello_cargo\ncd hello_cargo\n</code></pre>\n<p>Ceci crée un nouveau répertoire appelé <code>hello_cargo</code> avec la structure suivante :</p>\n<pre><code>hello_cargo/\n├── Cargo.toml        # Métadonnées du projet et dépendances\n├── Cargo.lock        # Verrouillage des versions (généré automatiquement)\n├── .gitignore        # Fichier Git ignore\n└── src/\n    └── main.rs       # Code source principal\n</code></pre>\n<h3>Le Fichier Cargo.toml</h3>\n<p>Le fichier <code>Cargo.toml</code> contient les métadonnées de ton projet :</p>\n<pre><code class=\"language-toml\">[package]\nname = &quot;hello_cargo&quot;\nversion = &quot;0.1.0&quot;\nedition = &quot;2021&quot;        # Édition de Rust à utiliser\n\n[dependencies]\n# Les dépendances seront listées ici\n</code></pre>\n<h3>Commandes Cargo Essentielles</h3>\n<pre><code class=\"language-bash\">cargo build           # Compile le projet (debug mode)\ncargo build --release # Compile en mode optimisé (release)\ncargo run             # Compile et exécute le projet\ncargo check           # Vérifie que le code compile sans générer l&#39;exécutable\ncargo clean           # Nettoie les fichiers de build\ncargo test            # Exécute les tests\ncargo doc             # Génère la documentation\n</code></pre>\n<h3>Exemple Pratique avec une Dépendance</h3>\n<p>Modifions notre projet pour utiliser une dépendance externe. Éditons <code>Cargo.toml</code> :</p>\n<pre><code class=\"language-toml\">[package]\nname = &quot;hello_cargo&quot;\nversion = &quot;0.1.0&quot;\nedition = &quot;2021&quot;\n\n[dependencies]\nrand = &quot;0.8&quot;\n</code></pre>\n<p>Maintenant, modifions <code>src/main.rs</code> :</p>\n<pre><code class=\"language-rust\">use rand::Rng;  // Importer le trait Rng\n\nfn main() {\n    println!(&quot;Hello, World!&quot;);\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    println!(&quot;Le nombre secret est : {}&quot;, secret_number);\n}\n</code></pre>\n<p>Exécute avec <code>cargo run</code> - Cargo téléchargera et compilera automatiquement la dépendance <code>rand</code>.</p>\n<h2>Concepts Clés de Rust</h2>\n<h3>Variables et Mutabilité</h3>\n<p>Par défaut, les variables en Rust sont <strong>immutables</strong> :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let x = 5;\n    println!(&quot;La valeur de x est : {}&quot;, x);\n    \n    // x = 6; // ❌ ERREUR : cannot assign twice to immutable variable\n}\n</code></pre>\n<p>Pour rendre une variable mutable, utilise le mot-clé <code>mut</code> :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let mut y = 5;\n    println!(&quot;La valeur de y est : {}&quot;, y);\n    \n    y = 6; // ✅ OK : y est mutable\n    println!(&quot;La valeur de y est maintenant : {}&quot;, y);\n}\n</code></pre>\n<h3>Constantes vs Variables</h3>\n<pre><code class=\"language-rust\">const PI: f64 = 3.14159;  // Constante - toujours immutable\n\nfn main() {\n    let x = 5;        // Variable immutable\n    let mut y = 10;   // Variable mutable\n    \n    println!(&quot;PI = {}, x = {}, y = {}&quot;, PI, x, y);\n}\n</code></pre>\n<h3>Shadowing (Masquage)</h3>\n<p>Rust permet de &quot;masquer&quot; une variable en déclarant une nouvelle variable avec le même nom :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let x = 5;\n    let x = x + 1;    // Nouveau x qui masque le précédent\n    let x = x * 2;    // Encore un nouveau x\n    \n    println!(&quot;La valeur de x est : {}&quot;, x); // 12\n    \n    // On peut même changer le type\n    let spaces = &quot;   &quot;;        // &amp;str\n    let spaces = spaces.len(); // usize\n    println!(&quot;Nombre d&#39;espaces : {}&quot;, spaces);\n}\n</code></pre>\n<h3>Types de Données de Base</h3>\n<pre><code class=\"language-rust\">fn main() {\n    // Integers\n    let signed: i32 = -42;      // 32-bit signé\n    let unsigned: u32 = 42;     // 32-bit non-signé\n    \n    // Floats\n    let pi: f64 = 3.14159;      // 64-bit (default)\n    let e: f32 = 2.718;         // 32-bit\n    \n    // Boolean\n    let is_rust_awesome: bool = true;\n    \n    // Character (Unicode)\n    let heart: char = &#39;💖&#39;;\n    \n    // String slice\n    let greeting: &amp;str = &quot;Bonjour&quot;;\n    \n    // String owned\n    let name: String = String::from(&quot;Rust&quot;);\n    \n    println!(&quot;i32: {}, u32: {}, f64: {}, f32: {}&quot;, signed, unsigned, pi, e);\n    println!(&quot;bool: {}, char: {}, &amp;str: {}, String: {}&quot;, \n             is_rust_awesome, heart, greeting, name);\n}\n</code></pre>\n<h3>Tuples et Arrays</h3>\n<pre><code class=\"language-rust\">fn main() {\n    // Tuple - types mixtes, taille fixe\n    let person: (String, i32, bool) = (String::from(&quot;Alice&quot;), 25, true);\n    let (name, age, is_student) = person; // Destructuring\n    \n    println!(&quot;{} a {} ans, étudiant: {}&quot;, name, age, is_student);\n    \n    // Access par index\n    let coordinates = (3.0, 4.0);\n    println!(&quot;x: {}, y: {}&quot;, coordinates.0, coordinates.1);\n    \n    // Array - même type, taille fixe\n    let numbers: [i32; 5] = [1, 2, 3, 4, 5];\n    let first = numbers[0];\n    let length = numbers.len();\n    \n    println!(&quot;Premier élément: {}, longueur: {}&quot;, first, length);\n    \n    // Array avec valeur répétée\n    let zeros = [0; 10]; // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    println!(&quot;Array de zéros: {:?}&quot;, zeros);\n}\n</code></pre>\n<h2>Ownership (Propriété)</h2>\n<p>L&#39;ownership est la fonctionnalité la plus unique de Rust et permet la memory safety sans garbage collection. Les règles principales sont :</p>\n<ol>\n<li><strong>Chaque valeur en Rust a une variable qui en est le propriétaire</strong></li>\n<li><strong>Il ne peut y avoir qu&#39;un seul propriétaire à la fois</strong></li>\n<li><strong>Quand le propriétaire sort du scope, la valeur sera supprimée</strong></li>\n</ol>\n<h3>Exemple de Move</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    let s2 = s1; // ✅ s1 est &quot;moved&quot; vers s2, s1 n&#39;est plus valide\n    \n    // println!(&quot;{}&quot;, s1); // ❌ ERREUR : borrow of moved value\n    println!(&quot;{}&quot;, s2);     // ✅ OK\n}\n</code></pre>\n<h3>Clone pour Copier</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    let s2 = s1.clone(); // ✅ Copie profonde explicite\n    \n    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2); // ✅ Les deux sont valides\n}\n</code></pre>\n<h3>Copy Types</h3>\n<p>Certains types implémentent le trait <code>Copy</code> et sont copiés automatiquement :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let x = 5;       // i32 implémente Copy\n    let y = x;       // x est copié vers y\n    \n    println!(&quot;x = {}, y = {}&quot;, x, y); // ✅ Les deux sont valides\n    \n    // Types qui implémentent Copy :\n    // - Tous les types entiers (i32, u32, etc.)\n    // - Types booléens (bool)\n    // - Types flottants (f32, f64)\n    // - Character (char)\n    // - Tuples contenant uniquement des types Copy\n}\n</code></pre>\n<h3>Ownership et Functions</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let s = String::from(&quot;hello&quot;);\n    \n    takes_ownership(s);              // s est moved dans la fonction\n    // println!(&quot;{}&quot;, s);            // ❌ ERREUR : s n&#39;est plus valide\n    \n    let x = 5;\n    makes_copy(x);                   // x est copié dans la fonction\n    println!(&quot;{}&quot;, x);               // ✅ OK : x est encore valide\n}\n\nfn takes_ownership(some_string: String) { // some_string entre dans le scope\n    println!(&quot;{}&quot;, some_string);\n} // some_string sort du scope et est supprimé\n\nfn makes_copy(some_integer: i32) { // some_integer entre dans le scope\n    println!(&quot;{}&quot;, some_integer);\n} // some_integer sort du scope, mais rien de spécial ne se passe\n</code></pre>\n<h3>Références et Emprunts</h3>\n<p>Pour utiliser une valeur sans prendre l&#39;ownership, utilise les <strong>références</strong> :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    \n    let len = calculate_length(&amp;s1); // Passer une référence\n    \n    println!(&quot;La longueur de &#39;{}&#39; est {}.&quot;, s1, len); // s1 toujours valide\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize { // s est une référence à String\n    s.len()\n} // s sort du scope, mais ne possède pas la donnée, rien n&#39;est supprimé\n</code></pre>\n<h3>Références Mutables</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let mut s = String::from(&quot;hello&quot;);\n    \n    change(&amp;mut s); // Passer une référence mutable\n    \n    println!(&quot;{}&quot;, s);\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(&quot;, world&quot;);\n}\n</code></pre>\n<p><strong>Règles des références :</strong></p>\n<ul>\n<li>Une seule référence mutable OU plusieurs références immutables</li>\n<li>Les références doivent toujours être valides</li>\n</ul>\n<h2>Structures de Contrôle</h2>\n<h3>Conditions avec if</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let number = 6;\n    \n    if number % 4 == 0 {\n        println!(&quot;Le nombre est divisible par 4&quot;);\n    } else if number % 3 == 0 {\n        println!(&quot;Le nombre est divisible par 3&quot;);\n    } else if number % 2 == 0 {\n        println!(&quot;Le nombre est divisible par 2&quot;);\n    } else {\n        println!(&quot;Le nombre n&#39;est pas divisible par 4, 3, ou 2&quot;);\n    }\n    \n    // if est une expression\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n    println!(&quot;La valeur du nombre est : {}&quot;, number);\n}\n</code></pre>\n<h3>Boucles</h3>\n<pre><code class=\"language-rust\">fn main() {\n    // Boucle infinie\n    let mut counter = 0;\n    let result = loop {\n        counter += 1;\n        \n        if counter == 10 {\n            break counter * 2; // Retourner une valeur avec break\n        }\n    };\n    println!(&quot;Le résultat est {}&quot;, result);\n    \n    // Boucle while\n    let mut number = 3;\n    while number != 0 {\n        println!(&quot;{}!&quot;, number);\n        number -= 1;\n    }\n    println!(&quot;LIFTOFF!!!&quot;);\n    \n    // Boucle for\n    let a = [10, 20, 30, 40, 50];\n    for element in a {\n        println!(&quot;La valeur est : {}&quot;, element);\n    }\n    \n    // Range avec for\n    for number in (1..4).rev() {\n        println!(&quot;{}!&quot;, number);\n    }\n    println!(&quot;LIFTOFF!!!&quot;);\n}\n</code></pre>\n<h2>Functions</h2>\n<pre><code class=\"language-rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n    \n    another_function(5);\n    print_labeled_measurement(5, &#39;h&#39;);\n    \n    let x = plus_one(5);\n    println!(&quot;La valeur de x est : {}&quot;, x);\n}\n\nfn another_function(x: i32) {\n    println!(&quot;La valeur de x est : {}&quot;, x);\n}\n\nfn print_labeled_measurement(value: i32, unit_label: char) {\n    println!(&quot;La mesure est : {}{}&quot;, value, unit_label);\n}\n\n// Function avec valeur de retour\nfn plus_one(x: i32) -&gt; i32 {\n    x + 1 // Expression sans point-virgule = valeur de retour\n}\n\n// Avec return explicite\nfn minus_one(x: i32) -&gt; i32 {\n    return x - 1; // return explicite avec point-virgule\n}\n</code></pre>\n<h2>Gestion d&#39;Erreur de Base</h2>\n<h3>Option</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let some_number = Some(5);\n    let some_string = Some(&quot;a string&quot;);\n    let absent_number: Option&lt;i32&gt; = None;\n    \n    // Pattern matching avec match\n    match some_number {\n        Some(value) =&gt; println!(&quot;La valeur est {}&quot;, value),\n        None =&gt; println!(&quot;Aucune valeur&quot;),\n    }\n    \n    // Avec if let\n    if let Some(value) = some_number {\n        println!(&quot;La valeur est {}&quot;, value);\n    }\n}\n</code></pre>\n<h3>Result</h3>\n<pre><code class=\"language-rust\">use std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    // Gestion d&#39;erreur avec match\n    let file_result = File::open(&quot;hello.txt&quot;);\n    \n    let _file = match file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            ErrorKind::NotFound =&gt; {\n                println!(&quot;Fichier non trouvé !&quot;);\n                return;\n            }\n            other_error =&gt; {\n                println!(&quot;Problème à l&#39;ouverture du fichier : {:?}&quot;, other_error);\n                return;\n            }\n        },\n    };\n    \n    // Avec unwrap_or_else\n    let _file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            println!(&quot;Création du fichier...&quot;);\n            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {\n                panic!(&quot;Problème lors de la création du fichier : {:?}&quot;, error);\n            })\n        } else {\n            panic!(&quot;Problème à l&#39;ouverture du fichier : {:?}&quot;, error);\n        }\n    });\n}\n</code></pre>\n<h2>Premier Projet Pratique : Jeu de Devinette</h2>\n<p>Créons un jeu simple pour mettre en pratique ce que nous avons appris :</p>\n<pre><code class=\"language-rust\">use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(&quot;Devine le nombre !&quot;);\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    \n    loop {\n        println!(&quot;Saisie quelque chose.&quot;);\n        \n        let mut guess = String::new();\n        \n        io::stdin()\n            .read_line(&amp;mut guess)\n            .expect(&quot;Échec de la lecture de la ligne&quot;);\n            \n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; {\n                println!(&quot;Entre un nombre valide !&quot;);\n                continue;\n            }\n        };\n        \n        println!(&quot;Tu as deviné : {}&quot;, guess);\n        \n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(&quot;Trop petit !&quot;),\n            Ordering::Greater =&gt; println!(&quot;Trop grand !&quot;),\n            Ordering::Equal =&gt; {\n                println!(&quot;Tu as gagné !&quot;);\n                break;\n            }\n        }\n    }\n}\n</code></pre>\n<p>Pour ce projet, ajoute dans ton <code>Cargo.toml</code> :</p>\n<pre><code class=\"language-toml\">[dependencies]\nrand = &quot;0.8&quot;\n</code></pre>\n<h2>Outils Utiles</h2>\n<h3>Formatage du Code</h3>\n<pre><code class=\"language-bash\">cargo fmt  # Formate automatiquement ton code\n</code></pre>\n<h3>Linting</h3>\n<pre><code class=\"language-bash\">cargo clippy  # Analyse statique pour améliorer ton code\n</code></pre>\n<h3>Tests</h3>\n<pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    \n    #[test]\n    #[should_panic]\n    fn another() {\n        panic!(&quot;Make this test fail&quot;);\n    }\n}\n</code></pre>\n<p>Exécute avec <code>cargo test</code>.</p>\n<h2>Prochaines Étapes</h2>\n<p>Maintenant que tu as les bases, Essaie de construire un petit projet pour pratiquer vos compétences. Voici quelques suggestions :</p>\n<h3>Projets Débutants</h3>\n<ol>\n<li><strong>Calculatrice en ligne de commande</strong></li>\n<li><strong>Convertisseur de température</strong></li>\n<li><strong>Gestionnaire de liste de tâches simple</strong></li>\n<li><strong>Générateur de mots de passe</strong></li>\n</ol>\n<h3>Ressources d&#39;Apprentissage</h3>\n<p>La documentation Rust est excellente pour approfondir vos connaissances :</p>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">Le Livre Rust (The Rust Book)</a> - Guide complet et officiel</li>\n<li><a href=\"https://doc.rust-lang.org/rust-by-example/\">Rust by Example</a> - Apprendre par l&#39;exemple</li>\n<li><a href=\"https://github.com/rust-lang/rustlings\">Rustlings</a> - Petits exercices pratiques</li>\n<li><a href=\"https://rust-lang-nursery.github.io/rust-cookbook/\">Rust Cookbook</a> - Recettes de code</li>\n<li><a href=\"https://google.github.io/comprehensive-rust/\">Comprehensive Rust</a> - Cours Google</li>\n</ul>\n<h3>Communauté</h3>\n<ul>\n<li><a href=\"https://users.rust-lang.org/\">Forum officiel Rust</a></li>\n<li><a href=\"https://www.reddit.com/r/rust/\">Reddit r/rust</a></li>\n<li><a href=\"https://discord.gg/rust-lang-community\">Discord Rust Community</a></li>\n<li><a href=\"https://this-week-in-rust.org/\">This Week in Rust</a> - Newsletter hebdomadaire</li>\n</ul>\n<h3>Concepts Avancés à Explorer Ensuite</h3>\n<ol>\n<li><strong>Structs et Enums</strong></li>\n<li><strong>Pattern Matching avancé</strong></li>\n<li><strong>Traits et Generics</strong></li>\n<li><strong>Gestion des erreurs avancée</strong></li>\n<li><strong>Concurrence et parallélisme</strong></li>\n<li><strong>Macros</strong></li>\n<li><strong>Unsafe Rust</strong></li>\n</ol>\n<p>Bon codage avec Rust ! 🦀</p>\n<hr>\n<p><strong>Astuce :</strong> N&#39;hésite pas à expérimenter avec le code. Rust a un excellent compilateur qui te guidera avec des messages d&#39;erreur très informatifs. Chaque erreur est une opportunité d&#39;apprentissage !</p>\n",
    "author": "Mayorana",
    "category": "rust",
    "tags": [
      "rust",
      "programming",
      "beginners",
      "tutorial"
    ],
    "readingTime": "12 min",
    "locale": "fr",
    "seo": {
      "title": "Débuter avec Rust",
      "description": "Introduction à Rust, couvrant l'installation, la syntaxe de base, et ton premier projet.",
      "keywords": [
        "rust",
        "programming",
        "beginners",
        "tutorial"
      ]
    },
    "headings": [
      {
        "id": "configuration-de-ton-environnement",
        "text": "Configuration de Ton Environnement",
        "level": 2
      },
      {
        "id": "verification-de-linstallation",
        "text": "Vérification de l'Installation",
        "level": 3
      },
      {
        "id": "configuration-de-lediteur",
        "text": "Configuration de l'Éditeur",
        "level": 3
      },
      {
        "id": "ton-premier-programme-rust",
        "text": "Ton Premier Programme Rust",
        "level": 2
      },
      {
        "id": "anatomie-du-programme",
        "text": "Anatomie du Programme",
        "level": 3
      },
      {
        "id": "comprendre-cargo",
        "text": "Comprendre Cargo",
        "level": 2
      },
      {
        "id": "creer-un-nouveau-projet",
        "text": "Créer un Nouveau Projet",
        "level": 3
      },
      {
        "id": "le-fichier-cargotoml",
        "text": "Le Fichier Cargo.toml",
        "level": 3
      },
      {
        "id": "commandes-cargo-essentielles",
        "text": "Commandes Cargo Essentielles",
        "level": 3
      },
      {
        "id": "exemple-pratique-avec-une-dependance",
        "text": "Exemple Pratique avec une Dépendance",
        "level": 3
      },
      {
        "id": "concepts-cles-de-rust",
        "text": "Concepts Clés de Rust",
        "level": 2
      },
      {
        "id": "variables-et-mutabilite",
        "text": "Variables et Mutabilité",
        "level": 3
      },
      {
        "id": "constantes-vs-variables",
        "text": "Constantes vs Variables",
        "level": 3
      },
      {
        "id": "shadowing-masquage",
        "text": "Shadowing (Masquage)",
        "level": 3
      },
      {
        "id": "types-de-donnees-de-base",
        "text": "Types de Données de Base",
        "level": 3
      },
      {
        "id": "tuples-et-arrays",
        "text": "Tuples et Arrays",
        "level": 3
      },
      {
        "id": "ownership-propriete",
        "text": "Ownership (Propriété)",
        "level": 2
      },
      {
        "id": "exemple-de-move",
        "text": "Exemple de Move",
        "level": 3
      },
      {
        "id": "clone-pour-copier",
        "text": "Clone pour Copier",
        "level": 3
      },
      {
        "id": "copy-types",
        "text": "Copy Types",
        "level": 3
      },
      {
        "id": "ownership-et-functions",
        "text": "Ownership et Functions",
        "level": 3
      },
      {
        "id": "references-et-emprunts",
        "text": "Références et Emprunts",
        "level": 3
      },
      {
        "id": "references-mutables",
        "text": "Références Mutables",
        "level": 3
      },
      {
        "id": "structures-de-controle",
        "text": "Structures de Contrôle",
        "level": 2
      },
      {
        "id": "conditions-avec-if",
        "text": "Conditions avec if",
        "level": 3
      },
      {
        "id": "boucles",
        "text": "Boucles",
        "level": 3
      },
      {
        "id": "functions",
        "text": "Functions",
        "level": 2
      },
      {
        "id": "gestion-derreur-de-base",
        "text": "Gestion d'Erreur de Base",
        "level": 2
      },
      {
        "id": "option",
        "text": "Option",
        "level": 3
      },
      {
        "id": "result",
        "text": "Result",
        "level": 3
      },
      {
        "id": "premier-projet-pratique-jeu-de-devinette",
        "text": "Premier Projet Pratique : Jeu de Devinette",
        "level": 2
      },
      {
        "id": "outils-utiles",
        "text": "Outils Utiles",
        "level": 2
      },
      {
        "id": "formatage-du-code",
        "text": "Formatage du Code",
        "level": 3
      },
      {
        "id": "linting",
        "text": "Linting",
        "level": 3
      },
      {
        "id": "tests",
        "text": "Tests",
        "level": 3
      },
      {
        "id": "prochaines-etapes",
        "text": "Prochaines Étapes",
        "level": 2
      },
      {
        "id": "projets-debutants",
        "text": "Projets Débutants",
        "level": 3
      },
      {
        "id": "ressources-dapprentissage",
        "text": "Ressources d'Apprentissage",
        "level": 3
      },
      {
        "id": "communaute",
        "text": "Communauté",
        "level": 3
      },
      {
        "id": "concepts-avances-a-explorer-ensuite",
        "text": "Concepts Avancés à Explorer Ensuite",
        "level": 3
      }
    ]
  }
]