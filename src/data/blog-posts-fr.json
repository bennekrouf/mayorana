[
  {
    "id": "getting-started-with-rust-fr",
    "slug": "getting-started-with-rust-fr",
    "title": "D√©buter avec Rust",
    "date": "2025-04-15",
    "excerpt": "Introduction √† Rust, couvrant l'installation, la syntaxe de base, et ton premier projet.",
    "content": "Rust gagne consid√©rablement en popularit√© parmi les d√©veloppeurs pour son focus sur la performance, la memory safety, et la concurrence. Si tu es nouveau √† Rust, ce guide t'aidera √† d√©buter avec les bases.\n\n## Configuration de Ton Environnement\n\nD'abord, tu dois installer Rust. La fa√ßon la plus simple est d'utiliser rustup, l'installateur de toolchain Rust :\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\nCette commande t√©l√©chargera un script et d√©marrera le processus d'installation.\n\n### V√©rification de l'Installation\n\nUne fois l'installation termin√©e, v√©rifie que tout fonctionne correctement :\n\n```bash\nrustc --version\ncargo --version\n```\n\nTu dois voir les num√©ros de version de Rust et Cargo s'afficher.\n\n### Configuration de l'√âditeur\n\nPour une meilleure exp√©rience de d√©veloppement, configure ton √©diteur pr√©f√©r√© :\n\n**VS Code :**\n- Installe l'extension \"rust-analyzer\"\n- Installe l'extension \"CodeLLDB\" pour le debugging\n\n**IntelliJ/CLion :**\n- Installe le plugin \"Rust\"\n\n**Vim/Neovim :**\n- Utilise rust.vim et coc-rust-analyzer\n\n## Ton Premier Programme Rust\n\nCr√©ons un simple programme \"Hello, World!\". Cr√©√© un nouveau fichier appel√© `hello.rs` avec le contenu suivant :\n\n```rust\nfn main() {\n    println!(\"Hello, World!\");\n}\n```\n\nPour compiler et ex√©cuter ce programme, utilise les commandes suivantes :\n\n```bash\nrustc hello.rs\n./hello  # Sur Windows: hello.exe\n```\n\n### Anatomie du Programme\n\nAnalysons ce simple programme :\n\n```rust\nfn main() {           // Fonction principale - point d'entr√©e du programme\n    println!(         // Macro pour imprimer du texte\n        \"Hello, World!\" // String √† imprimer\n    );                // Point-virgule requis pour terminer l'expression\n}\n```\n\n**Points importants :**\n- `fn main()` est la fonction principale, ex√©cut√©e en premier\n- `println!` est une **macro** (note le `!`) qui imprime du texte\n- Les d√©clarations se terminent par un point-virgule `;`\n\n## Comprendre Cargo\n\nCargo est le syst√®me de build et gestionnaire de packages de Rust. Il g√®re de nombreuses t√¢ches comme compilateur ton code, t√©l√©charger des libraries, et compilateur ces libraries.\n\n### Cr√©er un Nouveau Projet\n\nPour cr√©er un nouveau projet avec Cargo :\n\n```bash\ncargo new hello_cargo\ncd hello_cargo\n```\n\nCeci cr√©e un nouveau r√©pertoire appel√© `hello_cargo` avec la structure suivante :\n\n```\nhello_cargo/\n‚îú‚îÄ‚îÄ Cargo.toml        # M√©tadonn√©es du projet et d√©pendances\n‚îú‚îÄ‚îÄ Cargo.lock        # Verrouillage des versions (g√©n√©r√© automatiquement)\n‚îú‚îÄ‚îÄ .gitignore        # Fichier Git ignore\n‚îî‚îÄ‚îÄ src/\n    ‚îî‚îÄ‚îÄ main.rs       # Code source principal\n```\n\n### Le Fichier Cargo.toml\n\nLe fichier `Cargo.toml` contient les m√©tadonn√©es de ton projet :\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"        # √âdition de Rust √† utiliser\n\n[dependencies]\n# Les d√©pendances seront list√©es ici\n```\n\n### Commandes Cargo Essentielles\n\n```bash\ncargo build           # Compile le projet (debug mode)\ncargo build --release # Compile en mode optimis√© (release)\ncargo run             # Compile et ex√©cute le projet\ncargo check           # V√©rifie que le code compile sans g√©n√©rer l'ex√©cutable\ncargo clean           # Nettoie les fichiers de build\ncargo test            # Ex√©cute les tests\ncargo doc             # G√©n√®re la documentation\n```\n\n### Exemple Pratique avec une D√©pendance\n\nModifions notre projet pour utiliser une d√©pendance externe. √âditons `Cargo.toml` :\n\n```toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nrand = \"0.8\"\n```\n\nMaintenant, modifions `src/main.rs` :\n\n```rust\nuse rand::Rng;  // Importer le trait Rng\n\nfn main() {\n    println!(\"Hello, World!\");\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    println!(\"Le nombre secret est : {}\", secret_number);\n}\n```\n\nEx√©cute avec `cargo run` - Cargo t√©l√©chargera et compilera automatiquement la d√©pendance `rand`.\n\n## Concepts Cl√©s de Rust\n\n### Variables et Mutabilit√©\n\nPar d√©faut, les variables en Rust sont **immutables** :\n\n```rust\nfn main() {\n    let x = 5;\n    println!(\"La valeur de x est : {}\", x);\n    \n    // x = 6; // ‚ùå ERREUR : cannot assign twice to immutable variable\n}\n```\n\nPour rendre une variable mutable, utilise le mot-cl√© `mut` :\n\n```rust\nfn main() {\n    let mut y = 5;\n    println!(\"La valeur de y est : {}\", y);\n    \n    y = 6; // ‚úÖ OK : y est mutable\n    println!(\"La valeur de y est maintenant : {}\", y);\n}\n```\n\n### Constantes vs Variables\n\n```rust\nconst PI: f64 = 3.14159;  // Constante - toujours immutable\n\nfn main() {\n    let x = 5;        // Variable immutable\n    let mut y = 10;   // Variable mutable\n    \n    println!(\"PI = {}, x = {}, y = {}\", PI, x, y);\n}\n```\n\n### Shadowing (Masquage)\n\nRust permet de \"masquer\" une variable en d√©clarant une nouvelle variable avec le m√™me nom :\n\n```rust\nfn main() {\n    let x = 5;\n    let x = x + 1;    // Nouveau x qui masque le pr√©c√©dent\n    let x = x * 2;    // Encore un nouveau x\n    \n    println!(\"La valeur de x est : {}\", x); // 12\n    \n    // On peut m√™me changer le type\n    let spaces = \"   \";        // &str\n    let spaces = spaces.len(); // usize\n    println!(\"Nombre d'espaces : {}\", spaces);\n}\n```\n\n### Types de Donn√©es de Base\n\n```rust\nfn main() {\n    // Integers\n    let signed: i32 = -42;      // 32-bit sign√©\n    let unsigned: u32 = 42;     // 32-bit non-sign√©\n    \n    // Floats\n    let pi: f64 = 3.14159;      // 64-bit (default)\n    let e: f32 = 2.718;         // 32-bit\n    \n    // Boolean\n    let is_rust_awesome: bool = true;\n    \n    // Character (Unicode)\n    let heart: char = 'üíñ';\n    \n    // String slice\n    let greeting: &str = \"Bonjour\";\n    \n    // String owned\n    let name: String = String::from(\"Rust\");\n    \n    println!(\"i32: {}, u32: {}, f64: {}, f32: {}\", signed, unsigned, pi, e);\n    println!(\"bool: {}, char: {}, &str: {}, String: {}\", \n             is_rust_awesome, heart, greeting, name);\n}\n```\n\n### Tuples et Arrays\n\n```rust\nfn main() {\n    // Tuple - types mixtes, taille fixe\n    let person: (String, i32, bool) = (String::from(\"Alice\"), 25, true);\n    let (name, age, is_student) = person; // Destructuring\n    \n    println!(\"{} a {} ans, √©tudiant: {}\", name, age, is_student);\n    \n    // Access par index\n    let coordinates = (3.0, 4.0);\n    println!(\"x: {}, y: {}\", coordinates.0, coordinates.1);\n    \n    // Array - m√™me type, taille fixe\n    let numbers: [i32; 5] = [1, 2, 3, 4, 5];\n    let first = numbers[0];\n    let length = numbers.len();\n    \n    println!(\"Premier √©l√©ment: {}, longueur: {}\", first, length);\n    \n    // Array avec valeur r√©p√©t√©e\n    let zeros = [0; 10]; // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    println!(\"Array de z√©ros: {:?}\", zeros);\n}\n```\n\n## Ownership (Propri√©t√©)\n\nL'ownership est la fonctionnalit√© la plus unique de Rust et permet la memory safety sans garbage collection. Les r√®gles principales sont :\n\n1. **Chaque valeur en Rust a une variable qui en est le propri√©taire**\n2. **Il ne peut y avoir qu'un seul propri√©taire √† la fois**\n3. **Quand le propri√©taire sort du scope, la valeur sera supprim√©e**\n\n### Exemple de Move\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1; // ‚úÖ s1 est \"moved\" vers s2, s1 n'est plus valide\n    \n    // println!(\"{}\", s1); // ‚ùå ERREUR : borrow of moved value\n    println!(\"{}\", s2);     // ‚úÖ OK\n}\n```\n\n### Clone pour Copier\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone(); // ‚úÖ Copie profonde explicite\n    \n    println!(\"s1 = {}, s2 = {}\", s1, s2); // ‚úÖ Les deux sont valides\n}\n```\n\n### Copy Types\n\nCertains types impl√©mentent le trait `Copy` et sont copi√©s automatiquement :\n\n```rust\nfn main() {\n    let x = 5;       // i32 impl√©mente Copy\n    let y = x;       // x est copi√© vers y\n    \n    println!(\"x = {}, y = {}\", x, y); // ‚úÖ Les deux sont valides\n    \n    // Types qui impl√©mentent Copy :\n    // - Tous les types entiers (i32, u32, etc.)\n    // - Types bool√©ens (bool)\n    // - Types flottants (f32, f64)\n    // - Character (char)\n    // - Tuples contenant uniquement des types Copy\n}\n```\n\n### Ownership et Functions\n\n```rust\nfn main() {\n    let s = String::from(\"hello\");\n    \n    takes_ownership(s);              // s est moved dans la fonction\n    // println!(\"{}\", s);            // ‚ùå ERREUR : s n'est plus valide\n    \n    let x = 5;\n    makes_copy(x);                   // x est copi√© dans la fonction\n    println!(\"{}\", x);               // ‚úÖ OK : x est encore valide\n}\n\nfn takes_ownership(some_string: String) { // some_string entre dans le scope\n    println!(\"{}\", some_string);\n} // some_string sort du scope et est supprim√©\n\nfn makes_copy(some_integer: i32) { // some_integer entre dans le scope\n    println!(\"{}\", some_integer);\n} // some_integer sort du scope, mais rien de sp√©cial ne se passe\n```\n\n### R√©f√©rences et Emprunts\n\nPour utiliser une valeur sans prendre l'ownership, utilise les **r√©f√©rences** :\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    \n    let len = calculate_length(&s1); // Passer une r√©f√©rence\n    \n    println!(\"La longueur de '{}' est {}.\", s1, len); // s1 toujours valide\n}\n\nfn calculate_length(s: &String) -> usize { // s est une r√©f√©rence √† String\n    s.len()\n} // s sort du scope, mais ne poss√®de pas la donn√©e, rien n'est supprim√©\n```\n\n### R√©f√©rences Mutables\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n    \n    change(&mut s); // Passer une r√©f√©rence mutable\n    \n    println!(\"{}\", s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n**R√®gles des r√©f√©rences :**\n- Une seule r√©f√©rence mutable OU plusieurs r√©f√©rences immutables\n- Les r√©f√©rences doivent toujours √™tre valides\n\n## Structures de Contr√¥le\n\n### Conditions avec if\n\n```rust\nfn main() {\n    let number = 6;\n    \n    if number % 4 == 0 {\n        println!(\"Le nombre est divisible par 4\");\n    } else if number % 3 == 0 {\n        println!(\"Le nombre est divisible par 3\");\n    } else if number % 2 == 0 {\n        println!(\"Le nombre est divisible par 2\");\n    } else {\n        println!(\"Le nombre n'est pas divisible par 4, 3, ou 2\");\n    }\n    \n    // if est une expression\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n    println!(\"La valeur du nombre est : {}\", number);\n}\n```\n\n### Boucles\n\n```rust\nfn main() {\n    // Boucle infinie\n    let mut counter = 0;\n    let result = loop {\n        counter += 1;\n        \n        if counter == 10 {\n            break counter * 2; // Retourner une valeur avec break\n        }\n    };\n    println!(\"Le r√©sultat est {}\", result);\n    \n    // Boucle while\n    let mut number = 3;\n    while number != 0 {\n        println!(\"{}!\", number);\n        number -= 1;\n    }\n    println!(\"LIFTOFF!!!\");\n    \n    // Boucle for\n    let a = [10, 20, 30, 40, 50];\n    for element in a {\n        println!(\"La valeur est : {}\", element);\n    }\n    \n    // Range avec for\n    for number in (1..4).rev() {\n        println!(\"{}!\", number);\n    }\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n## Functions\n\n```rust\nfn main() {\n    println!(\"Hello, world!\");\n    \n    another_function(5);\n    print_labeled_measurement(5, 'h');\n    \n    let x = plus_one(5);\n    println!(\"La valeur de x est : {}\", x);\n}\n\nfn another_function(x: i32) {\n    println!(\"La valeur de x est : {}\", x);\n}\n\nfn print_labeled_measurement(value: i32, unit_label: char) {\n    println!(\"La mesure est : {}{}\", value, unit_label);\n}\n\n// Function avec valeur de retour\nfn plus_one(x: i32) -> i32 {\n    x + 1 // Expression sans point-virgule = valeur de retour\n}\n\n// Avec return explicite\nfn minus_one(x: i32) -> i32 {\n    return x - 1; // return explicite avec point-virgule\n}\n```\n\n## Gestion d'Erreur de Base\n\n### Option\n\n```rust\nfn main() {\n    let some_number = Some(5);\n    let some_string = Some(\"a string\");\n    let absent_number: Option<i32> = None;\n    \n    // Pattern matching avec match\n    match some_number {\n        Some(value) => println!(\"La valeur est {}\", value),\n        None => println!(\"Aucune valeur\"),\n    }\n    \n    // Avec if let\n    if let Some(value) = some_number {\n        println!(\"La valeur est {}\", value);\n    }\n}\n```\n\n### Result\n\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    // Gestion d'erreur avec match\n    let file_result = File::open(\"hello.txt\");\n    \n    let _file = match file_result {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => {\n                println!(\"Fichier non trouv√© !\");\n                return;\n            }\n            other_error => {\n                println!(\"Probl√®me √† l'ouverture du fichier : {:?}\", other_error);\n                return;\n            }\n        },\n    };\n    \n    // Avec unwrap_or_else\n    let _file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            println!(\"Cr√©ation du fichier...\");\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Probl√®me lors de la cr√©ation du fichier : {:?}\", error);\n            })\n        } else {\n            panic!(\"Probl√®me √† l'ouverture du fichier : {:?}\", error);\n        }\n    });\n}\n```\n\n## Premier Projet Pratique : Jeu de Devinette\n\nCr√©ons un jeu simple pour mettre en pratique ce que nous avons appris :\n\n```rust\nuse rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"Devine le nombre !\");\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    \n    loop {\n        println!(\"Saisie quelque chose.\");\n        \n        let mut guess = String::new();\n        \n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"√âchec de la lecture de la ligne\");\n            \n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => {\n                println!(\"Entre un nombre valide !\");\n                continue;\n            }\n        };\n        \n        println!(\"Tu as devin√© : {}\", guess);\n        \n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Trop petit !\"),\n            Ordering::Greater => println!(\"Trop grand !\"),\n            Ordering::Equal => {\n                println!(\"Tu as gagn√© !\");\n                break;\n            }\n        }\n    }\n}\n```\n\nPour ce projet, ajoute dans ton `Cargo.toml` :\n\n```toml\n[dependencies]\nrand = \"0.8\"\n```\n\n## Outils Utiles\n\n### Formatage du Code\n\n```bash\ncargo fmt  # Formate automatiquement ton code\n```\n\n### Linting\n\n```bash\ncargo clippy  # Analyse statique pour am√©liorer ton code\n```\n\n### Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    \n    #[test]\n    #[should_panic]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n}\n```\n\nEx√©cute avec `cargo test`.\n\n## Prochaines √âtapes\n\nMaintenant que tu as les bases, Essaie de construire un petit projet pour pratiquer vos comp√©tences. Voici quelques suggestions :\n\n### Projets D√©butants\n1. **Calculatrice en ligne de commande**\n2. **Convertisseur de temp√©rature**\n3. **Gestionnaire de liste de t√¢ches simple**\n4. **G√©n√©rateur de mots de passe**\n\n### Ressources d'Apprentissage\n\nLa documentation Rust est excellente pour approfondir vos connaissances :\n\n- [Le Livre Rust (The Rust Book)](https://doc.rust-lang.org/book/) - Guide complet et officiel\n- [Rust by Example](https://doc.rust-lang.org/rust-by-example/) - Apprendre par l'exemple\n- [Rustlings](https://github.com/rust-lang/rustlings) - Petits exercices pratiques\n- [Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/) - Recettes de code\n- [Comprehensive Rust](https://google.github.io/comprehensive-rust/) - Cours Google\n\n### Communaut√©\n\n- [Forum officiel Rust](https://users.rust-lang.org/)\n- [Reddit r/rust](https://www.reddit.com/r/rust/)\n- [Discord Rust Community](https://discord.gg/rust-lang-community)\n- [This Week in Rust](https://this-week-in-rust.org/) - Newsletter hebdomadaire\n\n### Concepts Avanc√©s √† Explorer Ensuite\n\n1. **Structs et Enums**\n2. **Pattern Matching avanc√©**\n3. **Traits et Generics**\n4. **Gestion des erreurs avanc√©e**\n5. **Concurrence et parall√©lisme**\n6. **Macros**\n7. **Unsafe Rust**\n\nBon codage avec Rust ! ü¶Ä\n\n---\n\n**Astuce :** N'h√©site pas √† exp√©rimenter avec le code. Rust a un excellent compilateur qui te guidera avec des messages d'erreur tr√®s informatifs. Chaque erreur est une opportunit√© d'apprentissage !",
    "contentHtml": "<p>Rust gagne consid√©rablement en popularit√© parmi les d√©veloppeurs pour son focus sur la performance, la memory safety, et la concurrence. Si tu es nouveau √† Rust, ce guide t&#39;aidera √† d√©buter avec les bases.</p>\n<h2>Configuration de Ton Environnement</h2>\n<p>D&#39;abord, tu dois installer Rust. La fa√ßon la plus simple est d&#39;utiliser rustup, l&#39;installateur de toolchain Rust :</p>\n<pre><code class=\"language-bash\">curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>\n<p>Cette commande t√©l√©chargera un script et d√©marrera le processus d&#39;installation.</p>\n<h3>V√©rification de l&#39;Installation</h3>\n<p>Une fois l&#39;installation termin√©e, v√©rifie que tout fonctionne correctement :</p>\n<pre><code class=\"language-bash\">rustc --version\ncargo --version\n</code></pre>\n<p>Tu dois voir les num√©ros de version de Rust et Cargo s&#39;afficher.</p>\n<h3>Configuration de l&#39;√âditeur</h3>\n<p>Pour une meilleure exp√©rience de d√©veloppement, configure ton √©diteur pr√©f√©r√© :</p>\n<p><strong>VS Code :</strong></p>\n<ul>\n<li>Installe l&#39;extension &quot;rust-analyzer&quot;</li>\n<li>Installe l&#39;extension &quot;CodeLLDB&quot; pour le debugging</li>\n</ul>\n<p><strong>IntelliJ/CLion :</strong></p>\n<ul>\n<li>Installe le plugin &quot;Rust&quot;</li>\n</ul>\n<p><strong>Vim/Neovim :</strong></p>\n<ul>\n<li>Utilise rust.vim et coc-rust-analyzer</li>\n</ul>\n<h2>Ton Premier Programme Rust</h2>\n<p>Cr√©ons un simple programme &quot;Hello, World!&quot;. Cr√©√© un nouveau fichier appel√© <code>hello.rs</code> avec le contenu suivant :</p>\n<pre><code class=\"language-rust\">fn main() {\n    println!(&quot;Hello, World!&quot;);\n}\n</code></pre>\n<p>Pour compiler et ex√©cuter ce programme, utilise les commandes suivantes :</p>\n<pre><code class=\"language-bash\">rustc hello.rs\n./hello  # Sur Windows: hello.exe\n</code></pre>\n<h3>Anatomie du Programme</h3>\n<p>Analysons ce simple programme :</p>\n<pre><code class=\"language-rust\">fn main() {           // Fonction principale - point d&#39;entr√©e du programme\n    println!(         // Macro pour imprimer du texte\n        &quot;Hello, World!&quot; // String √† imprimer\n    );                // Point-virgule requis pour terminer l&#39;expression\n}\n</code></pre>\n<p><strong>Points importants :</strong></p>\n<ul>\n<li><code>fn main()</code> est la fonction principale, ex√©cut√©e en premier</li>\n<li><code>println!</code> est une <strong>macro</strong> (note le <code>!</code>) qui imprime du texte</li>\n<li>Les d√©clarations se terminent par un point-virgule <code>;</code></li>\n</ul>\n<h2>Comprendre Cargo</h2>\n<p>Cargo est le syst√®me de build et gestionnaire de packages de Rust. Il g√®re de nombreuses t√¢ches comme compilateur ton code, t√©l√©charger des libraries, et compilateur ces libraries.</p>\n<h3>Cr√©er un Nouveau Projet</h3>\n<p>Pour cr√©er un nouveau projet avec Cargo :</p>\n<pre><code class=\"language-bash\">cargo new hello_cargo\ncd hello_cargo\n</code></pre>\n<p>Ceci cr√©e un nouveau r√©pertoire appel√© <code>hello_cargo</code> avec la structure suivante :</p>\n<pre><code>hello_cargo/\n‚îú‚îÄ‚îÄ Cargo.toml        # M√©tadonn√©es du projet et d√©pendances\n‚îú‚îÄ‚îÄ Cargo.lock        # Verrouillage des versions (g√©n√©r√© automatiquement)\n‚îú‚îÄ‚îÄ .gitignore        # Fichier Git ignore\n‚îî‚îÄ‚îÄ src/\n    ‚îî‚îÄ‚îÄ main.rs       # Code source principal\n</code></pre>\n<h3>Le Fichier Cargo.toml</h3>\n<p>Le fichier <code>Cargo.toml</code> contient les m√©tadonn√©es de ton projet :</p>\n<pre><code class=\"language-toml\">[package]\nname = &quot;hello_cargo&quot;\nversion = &quot;0.1.0&quot;\nedition = &quot;2021&quot;        # √âdition de Rust √† utiliser\n\n[dependencies]\n# Les d√©pendances seront list√©es ici\n</code></pre>\n<h3>Commandes Cargo Essentielles</h3>\n<pre><code class=\"language-bash\">cargo build           # Compile le projet (debug mode)\ncargo build --release # Compile en mode optimis√© (release)\ncargo run             # Compile et ex√©cute le projet\ncargo check           # V√©rifie que le code compile sans g√©n√©rer l&#39;ex√©cutable\ncargo clean           # Nettoie les fichiers de build\ncargo test            # Ex√©cute les tests\ncargo doc             # G√©n√®re la documentation\n</code></pre>\n<h3>Exemple Pratique avec une D√©pendance</h3>\n<p>Modifions notre projet pour utiliser une d√©pendance externe. √âditons <code>Cargo.toml</code> :</p>\n<pre><code class=\"language-toml\">[package]\nname = &quot;hello_cargo&quot;\nversion = &quot;0.1.0&quot;\nedition = &quot;2021&quot;\n\n[dependencies]\nrand = &quot;0.8&quot;\n</code></pre>\n<p>Maintenant, modifions <code>src/main.rs</code> :</p>\n<pre><code class=\"language-rust\">use rand::Rng;  // Importer le trait Rng\n\nfn main() {\n    println!(&quot;Hello, World!&quot;);\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    println!(&quot;Le nombre secret est : {}&quot;, secret_number);\n}\n</code></pre>\n<p>Ex√©cute avec <code>cargo run</code> - Cargo t√©l√©chargera et compilera automatiquement la d√©pendance <code>rand</code>.</p>\n<h2>Concepts Cl√©s de Rust</h2>\n<h3>Variables et Mutabilit√©</h3>\n<p>Par d√©faut, les variables en Rust sont <strong>immutables</strong> :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let x = 5;\n    println!(&quot;La valeur de x est : {}&quot;, x);\n    \n    // x = 6; // ‚ùå ERREUR : cannot assign twice to immutable variable\n}\n</code></pre>\n<p>Pour rendre une variable mutable, utilise le mot-cl√© <code>mut</code> :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let mut y = 5;\n    println!(&quot;La valeur de y est : {}&quot;, y);\n    \n    y = 6; // ‚úÖ OK : y est mutable\n    println!(&quot;La valeur de y est maintenant : {}&quot;, y);\n}\n</code></pre>\n<h3>Constantes vs Variables</h3>\n<pre><code class=\"language-rust\">const PI: f64 = 3.14159;  // Constante - toujours immutable\n\nfn main() {\n    let x = 5;        // Variable immutable\n    let mut y = 10;   // Variable mutable\n    \n    println!(&quot;PI = {}, x = {}, y = {}&quot;, PI, x, y);\n}\n</code></pre>\n<h3>Shadowing (Masquage)</h3>\n<p>Rust permet de &quot;masquer&quot; une variable en d√©clarant une nouvelle variable avec le m√™me nom :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let x = 5;\n    let x = x + 1;    // Nouveau x qui masque le pr√©c√©dent\n    let x = x * 2;    // Encore un nouveau x\n    \n    println!(&quot;La valeur de x est : {}&quot;, x); // 12\n    \n    // On peut m√™me changer le type\n    let spaces = &quot;   &quot;;        // &amp;str\n    let spaces = spaces.len(); // usize\n    println!(&quot;Nombre d&#39;espaces : {}&quot;, spaces);\n}\n</code></pre>\n<h3>Types de Donn√©es de Base</h3>\n<pre><code class=\"language-rust\">fn main() {\n    // Integers\n    let signed: i32 = -42;      // 32-bit sign√©\n    let unsigned: u32 = 42;     // 32-bit non-sign√©\n    \n    // Floats\n    let pi: f64 = 3.14159;      // 64-bit (default)\n    let e: f32 = 2.718;         // 32-bit\n    \n    // Boolean\n    let is_rust_awesome: bool = true;\n    \n    // Character (Unicode)\n    let heart: char = &#39;üíñ&#39;;\n    \n    // String slice\n    let greeting: &amp;str = &quot;Bonjour&quot;;\n    \n    // String owned\n    let name: String = String::from(&quot;Rust&quot;);\n    \n    println!(&quot;i32: {}, u32: {}, f64: {}, f32: {}&quot;, signed, unsigned, pi, e);\n    println!(&quot;bool: {}, char: {}, &amp;str: {}, String: {}&quot;, \n             is_rust_awesome, heart, greeting, name);\n}\n</code></pre>\n<h3>Tuples et Arrays</h3>\n<pre><code class=\"language-rust\">fn main() {\n    // Tuple - types mixtes, taille fixe\n    let person: (String, i32, bool) = (String::from(&quot;Alice&quot;), 25, true);\n    let (name, age, is_student) = person; // Destructuring\n    \n    println!(&quot;{} a {} ans, √©tudiant: {}&quot;, name, age, is_student);\n    \n    // Access par index\n    let coordinates = (3.0, 4.0);\n    println!(&quot;x: {}, y: {}&quot;, coordinates.0, coordinates.1);\n    \n    // Array - m√™me type, taille fixe\n    let numbers: [i32; 5] = [1, 2, 3, 4, 5];\n    let first = numbers[0];\n    let length = numbers.len();\n    \n    println!(&quot;Premier √©l√©ment: {}, longueur: {}&quot;, first, length);\n    \n    // Array avec valeur r√©p√©t√©e\n    let zeros = [0; 10]; // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    println!(&quot;Array de z√©ros: {:?}&quot;, zeros);\n}\n</code></pre>\n<h2>Ownership (Propri√©t√©)</h2>\n<p>L&#39;ownership est la fonctionnalit√© la plus unique de Rust et permet la memory safety sans garbage collection. Les r√®gles principales sont :</p>\n<ol>\n<li><strong>Chaque valeur en Rust a une variable qui en est le propri√©taire</strong></li>\n<li><strong>Il ne peut y avoir qu&#39;un seul propri√©taire √† la fois</strong></li>\n<li><strong>Quand le propri√©taire sort du scope, la valeur sera supprim√©e</strong></li>\n</ol>\n<h3>Exemple de Move</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    let s2 = s1; // ‚úÖ s1 est &quot;moved&quot; vers s2, s1 n&#39;est plus valide\n    \n    // println!(&quot;{}&quot;, s1); // ‚ùå ERREUR : borrow of moved value\n    println!(&quot;{}&quot;, s2);     // ‚úÖ OK\n}\n</code></pre>\n<h3>Clone pour Copier</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    let s2 = s1.clone(); // ‚úÖ Copie profonde explicite\n    \n    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2); // ‚úÖ Les deux sont valides\n}\n</code></pre>\n<h3>Copy Types</h3>\n<p>Certains types impl√©mentent le trait <code>Copy</code> et sont copi√©s automatiquement :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let x = 5;       // i32 impl√©mente Copy\n    let y = x;       // x est copi√© vers y\n    \n    println!(&quot;x = {}, y = {}&quot;, x, y); // ‚úÖ Les deux sont valides\n    \n    // Types qui impl√©mentent Copy :\n    // - Tous les types entiers (i32, u32, etc.)\n    // - Types bool√©ens (bool)\n    // - Types flottants (f32, f64)\n    // - Character (char)\n    // - Tuples contenant uniquement des types Copy\n}\n</code></pre>\n<h3>Ownership et Functions</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let s = String::from(&quot;hello&quot;);\n    \n    takes_ownership(s);              // s est moved dans la fonction\n    // println!(&quot;{}&quot;, s);            // ‚ùå ERREUR : s n&#39;est plus valide\n    \n    let x = 5;\n    makes_copy(x);                   // x est copi√© dans la fonction\n    println!(&quot;{}&quot;, x);               // ‚úÖ OK : x est encore valide\n}\n\nfn takes_ownership(some_string: String) { // some_string entre dans le scope\n    println!(&quot;{}&quot;, some_string);\n} // some_string sort du scope et est supprim√©\n\nfn makes_copy(some_integer: i32) { // some_integer entre dans le scope\n    println!(&quot;{}&quot;, some_integer);\n} // some_integer sort du scope, mais rien de sp√©cial ne se passe\n</code></pre>\n<h3>R√©f√©rences et Emprunts</h3>\n<p>Pour utiliser une valeur sans prendre l&#39;ownership, utilise les <strong>r√©f√©rences</strong> :</p>\n<pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    \n    let len = calculate_length(&amp;s1); // Passer une r√©f√©rence\n    \n    println!(&quot;La longueur de &#39;{}&#39; est {}.&quot;, s1, len); // s1 toujours valide\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize { // s est une r√©f√©rence √† String\n    s.len()\n} // s sort du scope, mais ne poss√®de pas la donn√©e, rien n&#39;est supprim√©\n</code></pre>\n<h3>R√©f√©rences Mutables</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let mut s = String::from(&quot;hello&quot;);\n    \n    change(&amp;mut s); // Passer une r√©f√©rence mutable\n    \n    println!(&quot;{}&quot;, s);\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(&quot;, world&quot;);\n}\n</code></pre>\n<p><strong>R√®gles des r√©f√©rences :</strong></p>\n<ul>\n<li>Une seule r√©f√©rence mutable OU plusieurs r√©f√©rences immutables</li>\n<li>Les r√©f√©rences doivent toujours √™tre valides</li>\n</ul>\n<h2>Structures de Contr√¥le</h2>\n<h3>Conditions avec if</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let number = 6;\n    \n    if number % 4 == 0 {\n        println!(&quot;Le nombre est divisible par 4&quot;);\n    } else if number % 3 == 0 {\n        println!(&quot;Le nombre est divisible par 3&quot;);\n    } else if number % 2 == 0 {\n        println!(&quot;Le nombre est divisible par 2&quot;);\n    } else {\n        println!(&quot;Le nombre n&#39;est pas divisible par 4, 3, ou 2&quot;);\n    }\n    \n    // if est une expression\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n    println!(&quot;La valeur du nombre est : {}&quot;, number);\n}\n</code></pre>\n<h3>Boucles</h3>\n<pre><code class=\"language-rust\">fn main() {\n    // Boucle infinie\n    let mut counter = 0;\n    let result = loop {\n        counter += 1;\n        \n        if counter == 10 {\n            break counter * 2; // Retourner une valeur avec break\n        }\n    };\n    println!(&quot;Le r√©sultat est {}&quot;, result);\n    \n    // Boucle while\n    let mut number = 3;\n    while number != 0 {\n        println!(&quot;{}!&quot;, number);\n        number -= 1;\n    }\n    println!(&quot;LIFTOFF!!!&quot;);\n    \n    // Boucle for\n    let a = [10, 20, 30, 40, 50];\n    for element in a {\n        println!(&quot;La valeur est : {}&quot;, element);\n    }\n    \n    // Range avec for\n    for number in (1..4).rev() {\n        println!(&quot;{}!&quot;, number);\n    }\n    println!(&quot;LIFTOFF!!!&quot;);\n}\n</code></pre>\n<h2>Functions</h2>\n<pre><code class=\"language-rust\">fn main() {\n    println!(&quot;Hello, world!&quot;);\n    \n    another_function(5);\n    print_labeled_measurement(5, &#39;h&#39;);\n    \n    let x = plus_one(5);\n    println!(&quot;La valeur de x est : {}&quot;, x);\n}\n\nfn another_function(x: i32) {\n    println!(&quot;La valeur de x est : {}&quot;, x);\n}\n\nfn print_labeled_measurement(value: i32, unit_label: char) {\n    println!(&quot;La mesure est : {}{}&quot;, value, unit_label);\n}\n\n// Function avec valeur de retour\nfn plus_one(x: i32) -&gt; i32 {\n    x + 1 // Expression sans point-virgule = valeur de retour\n}\n\n// Avec return explicite\nfn minus_one(x: i32) -&gt; i32 {\n    return x - 1; // return explicite avec point-virgule\n}\n</code></pre>\n<h2>Gestion d&#39;Erreur de Base</h2>\n<h3>Option</h3>\n<pre><code class=\"language-rust\">fn main() {\n    let some_number = Some(5);\n    let some_string = Some(&quot;a string&quot;);\n    let absent_number: Option&lt;i32&gt; = None;\n    \n    // Pattern matching avec match\n    match some_number {\n        Some(value) =&gt; println!(&quot;La valeur est {}&quot;, value),\n        None =&gt; println!(&quot;Aucune valeur&quot;),\n    }\n    \n    // Avec if let\n    if let Some(value) = some_number {\n        println!(&quot;La valeur est {}&quot;, value);\n    }\n}\n</code></pre>\n<h3>Result</h3>\n<pre><code class=\"language-rust\">use std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    // Gestion d&#39;erreur avec match\n    let file_result = File::open(&quot;hello.txt&quot;);\n    \n    let _file = match file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            ErrorKind::NotFound =&gt; {\n                println!(&quot;Fichier non trouv√© !&quot;);\n                return;\n            }\n            other_error =&gt; {\n                println!(&quot;Probl√®me √† l&#39;ouverture du fichier : {:?}&quot;, other_error);\n                return;\n            }\n        },\n    };\n    \n    // Avec unwrap_or_else\n    let _file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            println!(&quot;Cr√©ation du fichier...&quot;);\n            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {\n                panic!(&quot;Probl√®me lors de la cr√©ation du fichier : {:?}&quot;, error);\n            })\n        } else {\n            panic!(&quot;Probl√®me √† l&#39;ouverture du fichier : {:?}&quot;, error);\n        }\n    });\n}\n</code></pre>\n<h2>Premier Projet Pratique : Jeu de Devinette</h2>\n<p>Cr√©ons un jeu simple pour mettre en pratique ce que nous avons appris :</p>\n<pre><code class=\"language-rust\">use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(&quot;Devine le nombre !&quot;);\n    \n    let secret_number = rand::thread_rng().gen_range(1..=100);\n    \n    loop {\n        println!(&quot;Saisie quelque chose.&quot;);\n        \n        let mut guess = String::new();\n        \n        io::stdin()\n            .read_line(&amp;mut guess)\n            .expect(&quot;√âchec de la lecture de la ligne&quot;);\n            \n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; {\n                println!(&quot;Entre un nombre valide !&quot;);\n                continue;\n            }\n        };\n        \n        println!(&quot;Tu as devin√© : {}&quot;, guess);\n        \n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(&quot;Trop petit !&quot;),\n            Ordering::Greater =&gt; println!(&quot;Trop grand !&quot;),\n            Ordering::Equal =&gt; {\n                println!(&quot;Tu as gagn√© !&quot;);\n                break;\n            }\n        }\n    }\n}\n</code></pre>\n<p>Pour ce projet, ajoute dans ton <code>Cargo.toml</code> :</p>\n<pre><code class=\"language-toml\">[dependencies]\nrand = &quot;0.8&quot;\n</code></pre>\n<h2>Outils Utiles</h2>\n<h3>Formatage du Code</h3>\n<pre><code class=\"language-bash\">cargo fmt  # Formate automatiquement ton code\n</code></pre>\n<h3>Linting</h3>\n<pre><code class=\"language-bash\">cargo clippy  # Analyse statique pour am√©liorer ton code\n</code></pre>\n<h3>Tests</h3>\n<pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    \n    #[test]\n    #[should_panic]\n    fn another() {\n        panic!(&quot;Make this test fail&quot;);\n    }\n}\n</code></pre>\n<p>Ex√©cute avec <code>cargo test</code>.</p>\n<h2>Prochaines √âtapes</h2>\n<p>Maintenant que tu as les bases, Essaie de construire un petit projet pour pratiquer vos comp√©tences. Voici quelques suggestions :</p>\n<h3>Projets D√©butants</h3>\n<ol>\n<li><strong>Calculatrice en ligne de commande</strong></li>\n<li><strong>Convertisseur de temp√©rature</strong></li>\n<li><strong>Gestionnaire de liste de t√¢ches simple</strong></li>\n<li><strong>G√©n√©rateur de mots de passe</strong></li>\n</ol>\n<h3>Ressources d&#39;Apprentissage</h3>\n<p>La documentation Rust est excellente pour approfondir vos connaissances :</p>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">Le Livre Rust (The Rust Book)</a> - Guide complet et officiel</li>\n<li><a href=\"https://doc.rust-lang.org/rust-by-example/\">Rust by Example</a> - Apprendre par l&#39;exemple</li>\n<li><a href=\"https://github.com/rust-lang/rustlings\">Rustlings</a> - Petits exercices pratiques</li>\n<li><a href=\"https://rust-lang-nursery.github.io/rust-cookbook/\">Rust Cookbook</a> - Recettes de code</li>\n<li><a href=\"https://google.github.io/comprehensive-rust/\">Comprehensive Rust</a> - Cours Google</li>\n</ul>\n<h3>Communaut√©</h3>\n<ul>\n<li><a href=\"https://users.rust-lang.org/\">Forum officiel Rust</a></li>\n<li><a href=\"https://www.reddit.com/r/rust/\">Reddit r/rust</a></li>\n<li><a href=\"https://discord.gg/rust-lang-community\">Discord Rust Community</a></li>\n<li><a href=\"https://this-week-in-rust.org/\">This Week in Rust</a> - Newsletter hebdomadaire</li>\n</ul>\n<h3>Concepts Avanc√©s √† Explorer Ensuite</h3>\n<ol>\n<li><strong>Structs et Enums</strong></li>\n<li><strong>Pattern Matching avanc√©</strong></li>\n<li><strong>Traits et Generics</strong></li>\n<li><strong>Gestion des erreurs avanc√©e</strong></li>\n<li><strong>Concurrence et parall√©lisme</strong></li>\n<li><strong>Macros</strong></li>\n<li><strong>Unsafe Rust</strong></li>\n</ol>\n<p>Bon codage avec Rust ! ü¶Ä</p>\n<hr>\n<p><strong>Astuce :</strong> N&#39;h√©site pas √† exp√©rimenter avec le code. Rust a un excellent compilateur qui te guidera avec des messages d&#39;erreur tr√®s informatifs. Chaque erreur est une opportunit√© d&#39;apprentissage !</p>\n",
    "author": "Mayorana",
    "category": "rust",
    "tags": [
      "rust",
      "programming",
      "beginners",
      "tutorial"
    ],
    "readingTime": "12 min",
    "locale": "fr",
    "seo": {
      "title": "D√©buter avec Rust",
      "description": "Introduction √† Rust, couvrant l'installation, la syntaxe de base, et ton premier projet.",
      "keywords": [
        "rust",
        "programming",
        "beginners",
        "tutorial"
      ]
    },
    "headings": [
      {
        "id": "configuration-de-ton-environnement",
        "text": "Configuration de Ton Environnement",
        "level": 2
      },
      {
        "id": "verification-de-linstallation",
        "text": "V√©rification de l'Installation",
        "level": 3
      },
      {
        "id": "configuration-de-lediteur",
        "text": "Configuration de l'√âditeur",
        "level": 3
      },
      {
        "id": "ton-premier-programme-rust",
        "text": "Ton Premier Programme Rust",
        "level": 2
      },
      {
        "id": "anatomie-du-programme",
        "text": "Anatomie du Programme",
        "level": 3
      },
      {
        "id": "comprendre-cargo",
        "text": "Comprendre Cargo",
        "level": 2
      },
      {
        "id": "creer-un-nouveau-projet",
        "text": "Cr√©er un Nouveau Projet",
        "level": 3
      },
      {
        "id": "le-fichier-cargotoml",
        "text": "Le Fichier Cargo.toml",
        "level": 3
      },
      {
        "id": "commandes-cargo-essentielles",
        "text": "Commandes Cargo Essentielles",
        "level": 3
      },
      {
        "id": "exemple-pratique-avec-une-dependance",
        "text": "Exemple Pratique avec une D√©pendance",
        "level": 3
      },
      {
        "id": "concepts-cles-de-rust",
        "text": "Concepts Cl√©s de Rust",
        "level": 2
      },
      {
        "id": "variables-et-mutabilite",
        "text": "Variables et Mutabilit√©",
        "level": 3
      },
      {
        "id": "constantes-vs-variables",
        "text": "Constantes vs Variables",
        "level": 3
      },
      {
        "id": "shadowing-masquage",
        "text": "Shadowing (Masquage)",
        "level": 3
      },
      {
        "id": "types-de-donnees-de-base",
        "text": "Types de Donn√©es de Base",
        "level": 3
      },
      {
        "id": "tuples-et-arrays",
        "text": "Tuples et Arrays",
        "level": 3
      },
      {
        "id": "ownership-propriete",
        "text": "Ownership (Propri√©t√©)",
        "level": 2
      },
      {
        "id": "exemple-de-move",
        "text": "Exemple de Move",
        "level": 3
      },
      {
        "id": "clone-pour-copier",
        "text": "Clone pour Copier",
        "level": 3
      },
      {
        "id": "copy-types",
        "text": "Copy Types",
        "level": 3
      },
      {
        "id": "ownership-et-functions",
        "text": "Ownership et Functions",
        "level": 3
      },
      {
        "id": "references-et-emprunts",
        "text": "R√©f√©rences et Emprunts",
        "level": 3
      },
      {
        "id": "references-mutables",
        "text": "R√©f√©rences Mutables",
        "level": 3
      },
      {
        "id": "structures-de-controle",
        "text": "Structures de Contr√¥le",
        "level": 2
      },
      {
        "id": "conditions-avec-if",
        "text": "Conditions avec if",
        "level": 3
      },
      {
        "id": "boucles",
        "text": "Boucles",
        "level": 3
      },
      {
        "id": "functions",
        "text": "Functions",
        "level": 2
      },
      {
        "id": "gestion-derreur-de-base",
        "text": "Gestion d'Erreur de Base",
        "level": 2
      },
      {
        "id": "option",
        "text": "Option",
        "level": 3
      },
      {
        "id": "result",
        "text": "Result",
        "level": 3
      },
      {
        "id": "premier-projet-pratique-jeu-de-devinette",
        "text": "Premier Projet Pratique : Jeu de Devinette",
        "level": 2
      },
      {
        "id": "outils-utiles",
        "text": "Outils Utiles",
        "level": 2
      },
      {
        "id": "formatage-du-code",
        "text": "Formatage du Code",
        "level": 3
      },
      {
        "id": "linting",
        "text": "Linting",
        "level": 3
      },
      {
        "id": "tests",
        "text": "Tests",
        "level": 3
      },
      {
        "id": "prochaines-etapes",
        "text": "Prochaines √âtapes",
        "level": 2
      },
      {
        "id": "projets-debutants",
        "text": "Projets D√©butants",
        "level": 3
      },
      {
        "id": "ressources-dapprentissage",
        "text": "Ressources d'Apprentissage",
        "level": 3
      },
      {
        "id": "communaute",
        "text": "Communaut√©",
        "level": 3
      },
      {
        "id": "concepts-avances-a-explorer-ensuite",
        "text": "Concepts Avanc√©s √† Explorer Ensuite",
        "level": 3
      }
    ]
  }
]