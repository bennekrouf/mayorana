[
  {
    "id": "closure-dispatch-rust",
    "slug": "closure-dispatch-rust",
    "title": "impl Fn() vs. Box<dyn Fn()>: Rust's Closure Dispatch Showdown",
    "date": "2025-07-08",
    "excerpt": "Comparing static and dynamic dispatch for closures in Rust, focusing on performance and use cases",
    "content": "Rust‚Äôs closure system offers two ways to handle function-like behavior: `impl Fn()` for static dispatch and `Box<dyn Fn()>` for dynamic dispatch. Each has distinct performance and flexibility characteristics, driven by Rust‚Äôs ownership, traits, and lifetimes. I‚Äôll compare them and explain when to choose one over the other.\n\n## Key Differences\n\n| **Aspect** | **impl Fn() (Static Dispatch)** | **Box<dyn Fn()> (Dynamic Dispatch)** |\n|------------|--------------------------------|--------------------------------------|\n| **Dispatch Mechanism** | Monomorphized at compile time (zero-cost) | Uses vtables (runtime lookup) |\n| **Performance** | Faster (~1‚Äì2 ns, direct call) | Slower (~5‚Äì10 ns, vtable lookup) |\n| **Flexibility** | Single concrete type per instance | Can store heterogeneous closures |\n| **Memory** | Stack-allocated (unless moved) | Heap-allocated (fat pointer + heap data) |\n| **Use Case** | Fixed closure type, performance-critical | Dynamic behavior, multiple closure types |\n\n## When to Use Each\n\n### 1. impl Fn() (Static Dispatch)\n- **Use When**:\n  - The closure type is fixed and known at compile time.\n  - Performance is critical (e.g., hot loops, embedded systems).\n  - Zero-cost abstractions are desired.\n- **Why**: The compiler generates a unique function for each closure type via monomorphization, enabling inlining and no runtime overhead.\n\n**Example**:\n```rust\nfn make_adder(x: i32) -> impl Fn(i32) -> i32 {\n    move |y| x + y\n}\n\nfn main() {\n    let add_five = make_adder(5); // Type: closure(5)\n    println!(\"{}\", add_five(3)); // 8\n}\n```\n\nNo heap allocation, direct function calls, and optimal performance.\n\n### 2. Box<dyn Fn()> (Dynamic Dispatch)\n- **Use When**:\n  - You need to store different closures in the same collection (e.g., callbacks).\n  - Closure types vary at runtime (e.g., plugin systems).\n  - Flexibility outweighs performance costs.\n- **Why**: `dyn Fn()` uses a vtable for runtime method resolution, allowing heterogeneous closures at the cost of heap allocation and lookup overhead.\n\n**Example**:\n```rust\nfn create_op(is_add: bool) -> Box<dyn Fn(i32, i32) -> i32> {\n    if is_add {\n        Box::new(|x, y| x + y)\n    } else {\n        Box::new(|x, y| x * y)\n    }\n}\n\nfn main() {\n    let add = create_op(true);\n    let mul = create_op(false);\n    println!(\"{} {}\", add(2, 3), mul(2, 3)); // 5 6\n}\n```\n\nSupports dynamic behavior, ideal for event handlers or plugins.\n\n## Lifetime Considerations\n\n- **Box<dyn Fn()>**: Requires explicit lifetimes if the closure captures references:\n  ```rust\n  struct Handler<'a> {\n      callback: Box<dyn Fn() -> &'a str + 'a>,\n  }\n  ```\n- **impl Fn()**: Lifetimes are typically inferred unless references are captured, simplifying usage.\n\n## Performance Trade-offs\n\n| **Scenario** | **impl Fn()** | **Box<dyn Fn()>** |\n|--------------|---------------|-------------------|\n| **Call Speed** | ~1‚Äì2 ns (direct call) | ~5‚Äì10 ns (vtable lookup) |\n| **Memory Overhead** | None (stack-allocated) | 16‚Äì24 bytes (fat pointer + heap data) |\n| **Code Bloat** | Possible (monomorphization) | Minimal (single vtable) |\n\n## Key Takeaways\n\n‚úÖ **Choose `impl Fn()` for**:\n- Performance-sensitive code (e.g., iterator chains).\n- Single closure type (e.g., factory functions).\n\n‚úÖ **Choose `Box<dyn Fn()>` for**:\n- Dynamic behavior (e.g., event handlers, plugins).\n- Storing mixed closure types (e.g., `Vec<Box<dyn Fn()>>`).\n\n**Real-World Examples**:\n- `impl Fn()`: Used in iterator adapters like `map` and `filter` for zero-cost performance.\n- `Box<dyn Fn()>`: Common in GUI frameworks for event callbacks where flexibility is key.\n\n## Verification\n\nTo quantify the performance difference, benchmark with `criterion`:\n\n```rust\nuse criterion::{black_box, Criterion};\nfn bench(c: &mut Criterion) {\n    let impl_fn = |x: i32| x + 5;\n    let dyn_fn: Box<dyn Fn(i32) -> i32> = Box::new(|x| x + 5);\n    c.bench_function(\"impl_fn\", |b| b.iter(|| impl_fn(black_box(3))));\n    c.bench_function(\"dyn_fn\", |b| b.iter(|| dyn_fn(black_box(3))));\n}\n```\n\nExpect `impl Fn()` to be faster and use less memory, confirming its suitability for performance-critical code.\n\n## Conclusion\n\nUse `impl Fn()` for zero-cost, static dispatch in performance-critical scenarios with known closure types. Opt for `Box<dyn Fn()>` when flexibility is needed, such as in plugin systems or event-driven applications requiring runtime polymorphism. Rust‚Äôs ownership and trait system ensure both approaches are safe, with the choice depending on the balance of performance versus dynamic requirements.",
    "contentHtml": "<p>Rust‚Äôs closure system offers two ways to handle function-like behavior: <code>impl Fn()</code> for static dispatch and <code>Box&lt;dyn Fn()&gt;</code> for dynamic dispatch. Each has distinct performance and flexibility characteristics, driven by Rust‚Äôs ownership, traits, and lifetimes. I‚Äôll compare them and explain when to choose one over the other.</p>\n<h2>Key Differences</h2>\n<table>\n<thead>\n<tr>\n<th><strong>Aspect</strong></th>\n<th><strong>impl Fn() (Static Dispatch)</strong></th>\n<th><strong>Box&lt;dyn Fn()&gt; (Dynamic Dispatch)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Dispatch Mechanism</strong></td>\n<td>Monomorphized at compile time (zero-cost)</td>\n<td>Uses vtables (runtime lookup)</td>\n</tr>\n<tr>\n<td><strong>Performance</strong></td>\n<td>Faster (~1‚Äì2 ns, direct call)</td>\n<td>Slower (~5‚Äì10 ns, vtable lookup)</td>\n</tr>\n<tr>\n<td><strong>Flexibility</strong></td>\n<td>Single concrete type per instance</td>\n<td>Can store heterogeneous closures</td>\n</tr>\n<tr>\n<td><strong>Memory</strong></td>\n<td>Stack-allocated (unless moved)</td>\n<td>Heap-allocated (fat pointer + heap data)</td>\n</tr>\n<tr>\n<td><strong>Use Case</strong></td>\n<td>Fixed closure type, performance-critical</td>\n<td>Dynamic behavior, multiple closure types</td>\n</tr>\n</tbody></table>\n<h2>When to Use Each</h2>\n<h3>1. impl Fn() (Static Dispatch)</h3>\n<ul>\n<li><strong>Use When</strong>:<ul>\n<li>The closure type is fixed and known at compile time.</li>\n<li>Performance is critical (e.g., hot loops, embedded systems).</li>\n<li>Zero-cost abstractions are desired.</li>\n</ul>\n</li>\n<li><strong>Why</strong>: The compiler generates a unique function for each closure type via monomorphization, enabling inlining and no runtime overhead.</li>\n</ul>\n<p><strong>Example</strong>:</p>\n<pre><code class=\"language-rust\">fn make_adder(x: i32) -&gt; impl Fn(i32) -&gt; i32 {\n    move |y| x + y\n}\n\nfn main() {\n    let add_five = make_adder(5); // Type: closure(5)\n    println!(&quot;{}&quot;, add_five(3)); // 8\n}\n</code></pre>\n<p>No heap allocation, direct function calls, and optimal performance.</p>\n<h3>2. Box&lt;dyn Fn()&gt; (Dynamic Dispatch)</h3>\n<ul>\n<li><strong>Use When</strong>:<ul>\n<li>You need to store different closures in the same collection (e.g., callbacks).</li>\n<li>Closure types vary at runtime (e.g., plugin systems).</li>\n<li>Flexibility outweighs performance costs.</li>\n</ul>\n</li>\n<li><strong>Why</strong>: <code>dyn Fn()</code> uses a vtable for runtime method resolution, allowing heterogeneous closures at the cost of heap allocation and lookup overhead.</li>\n</ul>\n<p><strong>Example</strong>:</p>\n<pre><code class=\"language-rust\">fn create_op(is_add: bool) -&gt; Box&lt;dyn Fn(i32, i32) -&gt; i32&gt; {\n    if is_add {\n        Box::new(|x, y| x + y)\n    } else {\n        Box::new(|x, y| x * y)\n    }\n}\n\nfn main() {\n    let add = create_op(true);\n    let mul = create_op(false);\n    println!(&quot;{} {}&quot;, add(2, 3), mul(2, 3)); // 5 6\n}\n</code></pre>\n<p>Supports dynamic behavior, ideal for event handlers or plugins.</p>\n<h2>Lifetime Considerations</h2>\n<ul>\n<li><strong>Box&lt;dyn Fn()&gt;</strong>: Requires explicit lifetimes if the closure captures references:<pre><code class=\"language-rust\">struct Handler&lt;&#39;a&gt; {\n    callback: Box&lt;dyn Fn() -&gt; &amp;&#39;a str + &#39;a&gt;,\n}\n</code></pre>\n</li>\n<li><strong>impl Fn()</strong>: Lifetimes are typically inferred unless references are captured, simplifying usage.</li>\n</ul>\n<h2>Performance Trade-offs</h2>\n<table>\n<thead>\n<tr>\n<th><strong>Scenario</strong></th>\n<th><strong>impl Fn()</strong></th>\n<th><strong>Box&lt;dyn Fn()&gt;</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Call Speed</strong></td>\n<td>~1‚Äì2 ns (direct call)</td>\n<td>~5‚Äì10 ns (vtable lookup)</td>\n</tr>\n<tr>\n<td><strong>Memory Overhead</strong></td>\n<td>None (stack-allocated)</td>\n<td>16‚Äì24 bytes (fat pointer + heap data)</td>\n</tr>\n<tr>\n<td><strong>Code Bloat</strong></td>\n<td>Possible (monomorphization)</td>\n<td>Minimal (single vtable)</td>\n</tr>\n</tbody></table>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong>Choose <code>impl Fn()</code> for</strong>:</p>\n<ul>\n<li>Performance-sensitive code (e.g., iterator chains).</li>\n<li>Single closure type (e.g., factory functions).</li>\n</ul>\n<p>‚úÖ <strong>Choose <code>Box&lt;dyn Fn()&gt;</code> for</strong>:</p>\n<ul>\n<li>Dynamic behavior (e.g., event handlers, plugins).</li>\n<li>Storing mixed closure types (e.g., <code>Vec&lt;Box&lt;dyn Fn()&gt;&gt;</code>).</li>\n</ul>\n<p><strong>Real-World Examples</strong>:</p>\n<ul>\n<li><code>impl Fn()</code>: Used in iterator adapters like <code>map</code> and <code>filter</code> for zero-cost performance.</li>\n<li><code>Box&lt;dyn Fn()&gt;</code>: Common in GUI frameworks for event callbacks where flexibility is key.</li>\n</ul>\n<h2>Verification</h2>\n<p>To quantify the performance difference, benchmark with <code>criterion</code>:</p>\n<pre><code class=\"language-rust\">use criterion::{black_box, Criterion};\nfn bench(c: &amp;mut Criterion) {\n    let impl_fn = |x: i32| x + 5;\n    let dyn_fn: Box&lt;dyn Fn(i32) -&gt; i32&gt; = Box::new(|x| x + 5);\n    c.bench_function(&quot;impl_fn&quot;, |b| b.iter(|| impl_fn(black_box(3))));\n    c.bench_function(&quot;dyn_fn&quot;, |b| b.iter(|| dyn_fn(black_box(3))));\n}\n</code></pre>\n<p>Expect <code>impl Fn()</code> to be faster and use less memory, confirming its suitability for performance-critical code.</p>\n<h2>Conclusion</h2>\n<p>Use <code>impl Fn()</code> for zero-cost, static dispatch in performance-critical scenarios with known closure types. Opt for <code>Box&lt;dyn Fn()&gt;</code> when flexibility is needed, such as in plugin systems or event-driven applications requiring runtime polymorphism. Rust‚Äôs ownership and trait system ensure both approaches are safe, with the choice depending on the balance of performance versus dynamic requirements.</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "closures",
      "dispatch",
      "performance",
      "traits"
    ],
    "readingTime": "4 min",
    "seo": {
      "title": "impl Fn() vs. Box<dyn Fn()>: Rust's Closure Dispatch Showdown",
      "description": "Comparing static and dynamic dispatch for closures in Rust, focusing on performance and use cases",
      "keywords": [
        "rust",
        "closures",
        "dispatch",
        "performance",
        "traits"
      ]
    },
    "headings": [
      {
        "id": "key-differences",
        "text": "Key Differences",
        "level": 2
      },
      {
        "id": "when-to-use-each",
        "text": "When to Use Each",
        "level": 2
      },
      {
        "id": "1-impl-fn-static-dispatch",
        "text": "1. impl Fn() (Static Dispatch)",
        "level": 3
      },
      {
        "id": "2-boxlessdyn-fngreater-dynamic-dispatch",
        "text": "2. Box<dyn Fn()> (Dynamic Dispatch)",
        "level": 3
      },
      {
        "id": "lifetime-considerations",
        "text": "Lifetime Considerations",
        "level": 2
      },
      {
        "id": "performance-trade-offs",
        "text": "Performance Trade-offs",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      },
      {
        "id": "verification",
        "text": "Verification",
        "level": 2
      },
      {
        "id": "conclusion",
        "text": "Conclusion",
        "level": 2
      }
    ]
  },
  {
    "id": "move-closures-rust",
    "slug": "move-closures-rust",
    "title": "What are move closures (move || { ... })? When are they necessary, and how do they interact with ownership?",
    "date": "2025-07-08",
    "excerpt": "Functions and closures in Rust, covering ownership, traits, lifetimes",
    "content": "A `move` closure (defined with the `move` keyword) forces the closure to take ownership of variables it captures from the environment. Unlike regular closures, which capture variables by reference (immutable or mutable) when possible, `move` closures move or copy the variables into the closure itself.\n\n## Key Mechanics\n\n### 1. Ownership Transfer\n\n- For **non-Copy** types (e.g., `String`, `Vec`), the closure takes ownership of the variable:\n  ```rust\n  let s = String::from(\"hello\");\n  let closure = move || println!(\"{}\", s); // `s` is moved into the closure\n  // println!(\"{}\", s); // ERROR: `s` was moved\n  ```\n\n- For **Copy** types (e.g., `i32`, `bool`), the closure copies the value:\n  ```rust\n  let x = 42;\n  let closure = move || println!(\"{}\", x); // `x` is copied\n  println!(\"{}\", x); // OK: `x` is still valid\n  ```\n\n### 2. Interaction with Closure Traits\n\nA `move` closure‚Äôs trait (`Fn`, `FnMut`, `FnOnce`) depends on how the captured variables are used:\n\n- **`Fn`**: Read-only access to captured variables.\n- **`FnMut`**: Mutates captured variables.\n- **`FnOnce`**: Consumes captured variables (e.g., `drop`).\n\n## When Are Move Closures Necessary?\n\n### 1. Closures Outliving Their Environment\n\nWhen a closure is used in a different scope (e.g., a thread or async task), it must own its data to avoid dangling references:\n```rust\nuse std::thread;\n\nlet data = String::from(\"thread-safe\");\nthread::spawn(move || { // `move` forces ownership of `data`\n    println!(\"{}\", data); // Safe: `data` lives in the closure\n}).join().unwrap();\n```\n\n### 2. Breaking Reference Cycles\n\nIf a closure needs to capture a value that‚Äôs also borrowed elsewhere, `move` ensures ownership is transferred:\n```rust\nlet mut vec = vec![1, 2, 3];\nlet closure = move || { // Takes ownership of `vec`\n    // vec.push(4); // ERROR: `vec` is moved (can‚Äôt mutate)\n};\n// vec.push(4); // ERROR: `vec` is moved into closure\n```\n\n### 3. Explicit Ownership Control\n\nWhen you want to avoid accidental borrows or force a copy:\n```rust\nlet x = 42;\nlet closure = || println!(\"{}\", x); // Borrows `x`\nlet move_closure = move || println!(\"{}\", x); // Copies `x` (since `i32` is `Copy`)\n```\n\n## Examples\n\n### 1. Non-Copy Type (Ownership Moved)\n```rust\nlet s = String::from(\"hello\");\nlet closure = move || println!(\"{}\", s);\nclosure(); // Works: closure owns `s`\n// closure(); // ERROR if `s` is consumed (e.g., `FnOnce`)\n```\n\n### 2. Copy Type (Value Copied)\n```rust\nlet x = 42;\nlet closure = move || x + 1; // Copies `x`\nprintln!(\"{}\", x); // OK: `x` is `Copy`\n```\n\n### 3. Mixing `move` and Mutation\n```rust\nlet mut count = 0;\nlet mut closure = move || { // `count` is copied (since `i32` is `Copy`)\n    count += 1; // Operates on the copied `count`\n    count\n};\nprintln!(\"{}\", closure()); // 1\nprintln!(\"{}\", closure()); // 2\nprintln!(\"{}\", count); // 0 (original unchanged)\n```\n\n## Pitfalls\n\n- **Unintended Moves**:\n  ```rust\n  let s = String::from(\"hello\");\n  let _ = move || println!(\"{}\", s); // `s` moved here\n  // println!(\"{}\", s); // ERROR: `s` is gone\n  ```\n\n- **Overusing `move`**:\n  Unnecessary copies/moves can hurt performance or cause compile errors.\n\n## Key Takeaways\n\n‚úÖ **Use `move` closures when**:\n- The closure outlives its environment (e.g., threads).\n- You need explicit ownership to avoid borrow checker issues.\n\n‚úÖ **Avoid `move` for**:\n- Local, short-lived closures that don‚Äôt escape their scope.\n- `Copy` types where borrowing is sufficient.\n\n**Try This**: What happens if you use `move` with a closure that captures a mutable reference (`&mut T`)?  \n**Answer**: The reference itself is moved (but the data it points to isn‚Äôt owned). This is rarely useful and may lead to lifetime errors!",
    "contentHtml": "<p>A <code>move</code> closure (defined with the <code>move</code> keyword) forces the closure to take ownership of variables it captures from the environment. Unlike regular closures, which capture variables by reference (immutable or mutable) when possible, <code>move</code> closures move or copy the variables into the closure itself.</p>\n<h2>Key Mechanics</h2>\n<h3>1. Ownership Transfer</h3>\n<ul>\n<li><p>For <strong>non-Copy</strong> types (e.g., <code>String</code>, <code>Vec</code>), the closure takes ownership of the variable:</p>\n<pre><code class=\"language-rust\">let s = String::from(&quot;hello&quot;);\nlet closure = move || println!(&quot;{}&quot;, s); // `s` is moved into the closure\n// println!(&quot;{}&quot;, s); // ERROR: `s` was moved\n</code></pre>\n</li>\n<li><p>For <strong>Copy</strong> types (e.g., <code>i32</code>, <code>bool</code>), the closure copies the value:</p>\n<pre><code class=\"language-rust\">let x = 42;\nlet closure = move || println!(&quot;{}&quot;, x); // `x` is copied\nprintln!(&quot;{}&quot;, x); // OK: `x` is still valid\n</code></pre>\n</li>\n</ul>\n<h3>2. Interaction with Closure Traits</h3>\n<p>A <code>move</code> closure‚Äôs trait (<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>) depends on how the captured variables are used:</p>\n<ul>\n<li><strong><code>Fn</code></strong>: Read-only access to captured variables.</li>\n<li><strong><code>FnMut</code></strong>: Mutates captured variables.</li>\n<li><strong><code>FnOnce</code></strong>: Consumes captured variables (e.g., <code>drop</code>).</li>\n</ul>\n<h2>When Are Move Closures Necessary?</h2>\n<h3>1. Closures Outliving Their Environment</h3>\n<p>When a closure is used in a different scope (e.g., a thread or async task), it must own its data to avoid dangling references:</p>\n<pre><code class=\"language-rust\">use std::thread;\n\nlet data = String::from(&quot;thread-safe&quot;);\nthread::spawn(move || { // `move` forces ownership of `data`\n    println!(&quot;{}&quot;, data); // Safe: `data` lives in the closure\n}).join().unwrap();\n</code></pre>\n<h3>2. Breaking Reference Cycles</h3>\n<p>If a closure needs to capture a value that‚Äôs also borrowed elsewhere, <code>move</code> ensures ownership is transferred:</p>\n<pre><code class=\"language-rust\">let mut vec = vec![1, 2, 3];\nlet closure = move || { // Takes ownership of `vec`\n    // vec.push(4); // ERROR: `vec` is moved (can‚Äôt mutate)\n};\n// vec.push(4); // ERROR: `vec` is moved into closure\n</code></pre>\n<h3>3. Explicit Ownership Control</h3>\n<p>When you want to avoid accidental borrows or force a copy:</p>\n<pre><code class=\"language-rust\">let x = 42;\nlet closure = || println!(&quot;{}&quot;, x); // Borrows `x`\nlet move_closure = move || println!(&quot;{}&quot;, x); // Copies `x` (since `i32` is `Copy`)\n</code></pre>\n<h2>Examples</h2>\n<h3>1. Non-Copy Type (Ownership Moved)</h3>\n<pre><code class=\"language-rust\">let s = String::from(&quot;hello&quot;);\nlet closure = move || println!(&quot;{}&quot;, s);\nclosure(); // Works: closure owns `s`\n// closure(); // ERROR if `s` is consumed (e.g., `FnOnce`)\n</code></pre>\n<h3>2. Copy Type (Value Copied)</h3>\n<pre><code class=\"language-rust\">let x = 42;\nlet closure = move || x + 1; // Copies `x`\nprintln!(&quot;{}&quot;, x); // OK: `x` is `Copy`\n</code></pre>\n<h3>3. Mixing <code>move</code> and Mutation</h3>\n<pre><code class=\"language-rust\">let mut count = 0;\nlet mut closure = move || { // `count` is copied (since `i32` is `Copy`)\n    count += 1; // Operates on the copied `count`\n    count\n};\nprintln!(&quot;{}&quot;, closure()); // 1\nprintln!(&quot;{}&quot;, closure()); // 2\nprintln!(&quot;{}&quot;, count); // 0 (original unchanged)\n</code></pre>\n<h2>Pitfalls</h2>\n<ul>\n<li><p><strong>Unintended Moves</strong>:</p>\n<pre><code class=\"language-rust\">let s = String::from(&quot;hello&quot;);\nlet _ = move || println!(&quot;{}&quot;, s); // `s` moved here\n// println!(&quot;{}&quot;, s); // ERROR: `s` is gone\n</code></pre>\n</li>\n<li><p><strong>Overusing <code>move</code></strong>:\nUnnecessary copies/moves can hurt performance or cause compile errors.</p>\n</li>\n</ul>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong>Use <code>move</code> closures when</strong>:</p>\n<ul>\n<li>The closure outlives its environment (e.g., threads).</li>\n<li>You need explicit ownership to avoid borrow checker issues.</li>\n</ul>\n<p>‚úÖ <strong>Avoid <code>move</code> for</strong>:</p>\n<ul>\n<li>Local, short-lived closures that don‚Äôt escape their scope.</li>\n<li><code>Copy</code> types where borrowing is sufficient.</li>\n</ul>\n<p><strong>Try This</strong>: What happens if you use <code>move</code> with a closure that captures a mutable reference (<code>&amp;mut T</code>)?<br><strong>Answer</strong>: The reference itself is moved (but the data it points to isn‚Äôt owned). This is rarely useful and may lead to lifetime errors!</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "closures",
      "ownership",
      "traits",
      "lifetimes"
    ],
    "readingTime": "4 min",
    "seo": {
      "title": "What are move closures (move || { ... })? When are they necessary, and how do they interact with ownership?",
      "description": "Functions and closures in Rust, covering ownership, traits, lifetimes",
      "keywords": [
        "rust",
        "closures",
        "ownership",
        "traits",
        "lifetimes"
      ]
    },
    "headings": [
      {
        "id": "key-mechanics",
        "text": "Key Mechanics",
        "level": 2
      },
      {
        "id": "1-ownership-transfer",
        "text": "1. Ownership Transfer",
        "level": 3
      },
      {
        "id": "2-interaction-with-closure-traits",
        "text": "2. Interaction with Closure Traits",
        "level": 3
      },
      {
        "id": "when-are-move-closures-necessary",
        "text": "When Are Move Closures Necessary?",
        "level": 2
      },
      {
        "id": "1-closures-outliving-their-environment",
        "text": "1. Closures Outliving Their Environment",
        "level": 3
      },
      {
        "id": "2-breaking-reference-cycles",
        "text": "2. Breaking Reference Cycles",
        "level": 3
      },
      {
        "id": "3-explicit-ownership-control",
        "text": "3. Explicit Ownership Control",
        "level": 3
      },
      {
        "id": "examples",
        "text": "Examples",
        "level": 2
      },
      {
        "id": "1-non-copy-type-ownership-moved",
        "text": "1. Non-Copy Type (Ownership Moved)",
        "level": 3
      },
      {
        "id": "2-copy-type-value-copied",
        "text": "2. Copy Type (Value Copied)",
        "level": 3
      },
      {
        "id": "3-mixing-move-and-mutation",
        "text": "3. Mixing `move` and Mutation",
        "level": 3
      },
      {
        "id": "pitfalls",
        "text": "Pitfalls",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "iter-methods-rust",
    "slug": "iter-methods-rust",
    "title": "How do into_iter(), iter(), and iter_mut() differ?",
    "date": "2025-07-08",
    "excerpt": "Collections (like Vec), iterators (into_iter, collect), and related concepts",
    "content": "These three methods are fundamental for working with collections in Rust, each serving distinct ownership and mutability use cases.\n\n## 1. `into_iter()` - Ownership-Consuming Iterator\n\n- **Takes ownership** of the collection (`self`).\n- **Produces** owned values (`T`) when iterating.\n- **Destroys** the original collection (can't be used afterward).\n\n```rust\nlet vec = vec![\"a\".to_string(), \"b\".to_string()];\nfor s in vec.into_iter() {  // `vec` is moved here\n    println!(\"{}\", s);      // `s` is a String (owned)\n}\n// println!(\"{:?}\", vec);  // ERROR: `vec` was consumed\n```\n\n**When to use**:\n- When you need to transform or consume the collection permanently.\n- For chaining iterator adapters that need ownership (e.g., `.filter().collect()`).\n\n## 2. `iter()` - Immutable Borrow Iterator\n\n- **Borrows** the collection immutably (`&self`).\n- **Produces** references (`&T`).\n- **Leaves** the collection intact.\n\n```rust\nlet vec = vec![\"a\", \"b\", \"c\"];\nfor s in vec.iter() {       // Borrows `vec`\n    println!(\"{}\", s);      // `s` is &&str (reference)\n}\nprintln!(\"{:?}\", vec);      // OK: `vec` still valid\n```\n\n**When to use**:\n- When you only need read-only access to elements.\n- For operations like searching (`.find()`) or inspection.\n\n## 3. `iter_mut()` - Mutable Borrow Iterator\n\n- **Borrows** the collection mutably (`&mut self`).\n- **Produces** mutable references (`&mut T`).\n- **Allows** in-place modification.\n\n```rust\nlet mut vec = vec![1, 2, 3];\nfor num in vec.iter_mut() {  // Mutable borrow\n    *num *= 2;               // Modify in place\n}\nprintln!(\"{:?}\", vec);       // [2, 4, 6]\n```\n\n**When to use**:\n- When you need to modify elements without reallocating.\n- For bulk updates (e.g., applying transformations).\n\n## Key Differences Summary\n\n| Method        | Ownership     | Yields     | Modifies Original? | Reuse Original? |\n|---------------|---------------|------------|--------------------|-----------------|\n| `into_iter()` | Consumes      | `T`        | ‚ùå (destroyed)      | ‚ùå              |\n| `iter()`      | Borrows       | `&T`       | ‚ùå                 | ‚úÖ              |\n| `iter_mut()`  | Mut borrow    | `&mut T`   | ‚úÖ                 | ‚úÖ              |\n\n## Common Pitfalls\n\n- **Accidental moves with `into_iter()`**:\n  ```rust\n  let vec = vec![1, 2];\n  let _ = vec.into_iter();  // `vec` moved here\n  // println!(\"{:?}\", vec); // ERROR!\n  ```\n\n- **Simultaneous mutable access**:\n  ```rust\n  let mut vec = vec![1, 2];\n  let iter = vec.iter_mut();\n  // vec.push(3);           // ERROR: Cannot borrow `vec` while iterator exists\n  ```\n\n## Real-World Examples\n\n- **`iter()` for read-only processing**:\n  ```rust\n  let words = vec![\"hello\", \"world\"];\n  let lengths: Vec<_> = words.iter().map(|s| s.len()).collect();  // [5, 5]\n  ```\n\n- **`iter_mut()` for in-place updates**:\n  ```rust\n  let mut scores = vec![85, 92, 78];\n  scores.iter_mut().for_each(|s| *s += 5);  // [90, 97, 83]\n  ```\n\n- **`into_iter()` for ownership transfer**:\n  ```rust\n  let matrix = vec![vec![1, 2], vec![3, 4]];\n  let flattened: Vec<_> = matrix.into_iter().flatten().collect();  // [1, 2, 3, 4]\n  ```\n\n## Performance Notes\n\n- `iter()` and `iter_mut()` are zero-cost (just pointers).\n- `into_iter()` may involve moves (but optimized for primitives like `i32`).\n\n**Try This**: What happens if you call `iter_mut()` on a `Vec<T>` where `T` doesn‚Äôt implement `Copy`, then try to modify the elements?  \n**Answer**: It works! The iterator yields `&mut T`, allowing direct mutation (e.g., `*item = new_value`).",
    "contentHtml": "<p>These three methods are fundamental for working with collections in Rust, each serving distinct ownership and mutability use cases.</p>\n<h2>1. <code>into_iter()</code> - Ownership-Consuming Iterator</h2>\n<ul>\n<li><strong>Takes ownership</strong> of the collection (<code>self</code>).</li>\n<li><strong>Produces</strong> owned values (<code>T</code>) when iterating.</li>\n<li><strong>Destroys</strong> the original collection (can&#39;t be used afterward).</li>\n</ul>\n<pre><code class=\"language-rust\">let vec = vec![&quot;a&quot;.to_string(), &quot;b&quot;.to_string()];\nfor s in vec.into_iter() {  // `vec` is moved here\n    println!(&quot;{}&quot;, s);      // `s` is a String (owned)\n}\n// println!(&quot;{:?}&quot;, vec);  // ERROR: `vec` was consumed\n</code></pre>\n<p><strong>When to use</strong>:</p>\n<ul>\n<li>When you need to transform or consume the collection permanently.</li>\n<li>For chaining iterator adapters that need ownership (e.g., <code>.filter().collect()</code>).</li>\n</ul>\n<h2>2. <code>iter()</code> - Immutable Borrow Iterator</h2>\n<ul>\n<li><strong>Borrows</strong> the collection immutably (<code>&amp;self</code>).</li>\n<li><strong>Produces</strong> references (<code>&amp;T</code>).</li>\n<li><strong>Leaves</strong> the collection intact.</li>\n</ul>\n<pre><code class=\"language-rust\">let vec = vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\nfor s in vec.iter() {       // Borrows `vec`\n    println!(&quot;{}&quot;, s);      // `s` is &amp;&amp;str (reference)\n}\nprintln!(&quot;{:?}&quot;, vec);      // OK: `vec` still valid\n</code></pre>\n<p><strong>When to use</strong>:</p>\n<ul>\n<li>When you only need read-only access to elements.</li>\n<li>For operations like searching (<code>.find()</code>) or inspection.</li>\n</ul>\n<h2>3. <code>iter_mut()</code> - Mutable Borrow Iterator</h2>\n<ul>\n<li><strong>Borrows</strong> the collection mutably (<code>&amp;mut self</code>).</li>\n<li><strong>Produces</strong> mutable references (<code>&amp;mut T</code>).</li>\n<li><strong>Allows</strong> in-place modification.</li>\n</ul>\n<pre><code class=\"language-rust\">let mut vec = vec![1, 2, 3];\nfor num in vec.iter_mut() {  // Mutable borrow\n    *num *= 2;               // Modify in place\n}\nprintln!(&quot;{:?}&quot;, vec);       // [2, 4, 6]\n</code></pre>\n<p><strong>When to use</strong>:</p>\n<ul>\n<li>When you need to modify elements without reallocating.</li>\n<li>For bulk updates (e.g., applying transformations).</li>\n</ul>\n<h2>Key Differences Summary</h2>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Ownership</th>\n<th>Yields</th>\n<th>Modifies Original?</th>\n<th>Reuse Original?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>into_iter()</code></td>\n<td>Consumes</td>\n<td><code>T</code></td>\n<td>‚ùå (destroyed)</td>\n<td>‚ùå</td>\n</tr>\n<tr>\n<td><code>iter()</code></td>\n<td>Borrows</td>\n<td><code>&amp;T</code></td>\n<td>‚ùå</td>\n<td>‚úÖ</td>\n</tr>\n<tr>\n<td><code>iter_mut()</code></td>\n<td>Mut borrow</td>\n<td><code>&amp;mut T</code></td>\n<td>‚úÖ</td>\n<td>‚úÖ</td>\n</tr>\n</tbody></table>\n<h2>Common Pitfalls</h2>\n<ul>\n<li><p><strong>Accidental moves with <code>into_iter()</code></strong>:</p>\n<pre><code class=\"language-rust\">let vec = vec![1, 2];\nlet _ = vec.into_iter();  // `vec` moved here\n// println!(&quot;{:?}&quot;, vec); // ERROR!\n</code></pre>\n</li>\n<li><p><strong>Simultaneous mutable access</strong>:</p>\n<pre><code class=\"language-rust\">let mut vec = vec![1, 2];\nlet iter = vec.iter_mut();\n// vec.push(3);           // ERROR: Cannot borrow `vec` while iterator exists\n</code></pre>\n</li>\n</ul>\n<h2>Real-World Examples</h2>\n<ul>\n<li><p><strong><code>iter()</code> for read-only processing</strong>:</p>\n<pre><code class=\"language-rust\">let words = vec![&quot;hello&quot;, &quot;world&quot;];\nlet lengths: Vec&lt;_&gt; = words.iter().map(|s| s.len()).collect();  // [5, 5]\n</code></pre>\n</li>\n<li><p><strong><code>iter_mut()</code> for in-place updates</strong>:</p>\n<pre><code class=\"language-rust\">let mut scores = vec![85, 92, 78];\nscores.iter_mut().for_each(|s| *s += 5);  // [90, 97, 83]\n</code></pre>\n</li>\n<li><p><strong><code>into_iter()</code> for ownership transfer</strong>:</p>\n<pre><code class=\"language-rust\">let matrix = vec![vec![1, 2], vec![3, 4]];\nlet flattened: Vec&lt;_&gt; = matrix.into_iter().flatten().collect();  // [1, 2, 3, 4]\n</code></pre>\n</li>\n</ul>\n<h2>Performance Notes</h2>\n<ul>\n<li><code>iter()</code> and <code>iter_mut()</code> are zero-cost (just pointers).</li>\n<li><code>into_iter()</code> may involve moves (but optimized for primitives like <code>i32</code>).</li>\n</ul>\n<p><strong>Try This</strong>: What happens if you call <code>iter_mut()</code> on a <code>Vec&lt;T&gt;</code> where <code>T</code> doesn‚Äôt implement <code>Copy</code>, then try to modify the elements?<br><strong>Answer</strong>: It works! The iterator yields <code>&amp;mut T</code>, allowing direct mutation (e.g., <code>*item = new_value</code>).</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "iterators",
      "collections",
      "ownership"
    ],
    "readingTime": "3 min",
    "seo": {
      "title": "How do into_iter(), iter(), and iter_mut() differ?",
      "description": "Collections (like Vec), iterators (into_iter, collect), and related concepts",
      "keywords": [
        "rust",
        "iterators",
        "collections",
        "ownership"
      ]
    },
    "headings": [
      {
        "id": "1-intoiter-ownership-consuming-iterator",
        "text": "1. `into_iter()` - Ownership-Consuming Iterator",
        "level": 2
      },
      {
        "id": "2-iter-immutable-borrow-iterator",
        "text": "2. `iter()` - Immutable Borrow Iterator",
        "level": 2
      },
      {
        "id": "3-itermut-mutable-borrow-iterator",
        "text": "3. `iter_mut()` - Mutable Borrow Iterator",
        "level": 2
      },
      {
        "id": "key-differences-summary",
        "text": "Key Differences Summary",
        "level": 2
      },
      {
        "id": "common-pitfalls",
        "text": "Common Pitfalls",
        "level": 2
      },
      {
        "id": "real-world-examples",
        "text": "Real-World Examples",
        "level": 2
      },
      {
        "id": "performance-notes",
        "text": "Performance Notes",
        "level": 2
      }
    ]
  },
  {
    "id": "fn-traits-rust",
    "slug": "fn-traits-rust",
    "title": "What are the differences between Fn, FnMut, and FnOnce?",
    "date": "2025-07-07",
    "excerpt": "Functions and closures in Rust, covering ownership, traits, lifetimes",
    "content": "Understanding the distinction between `Fn`, `FnMut`, and `FnOnce` traits is crucial for mastering Rust's closure system, ownership, and performance characteristics.\n\n## Closure Capturing\n\nClosures in Rust capture variables from their environment in one of three ways, depending on how the variables are used:\n\n- **Immutable Borrow (`&T`)**: If the closure only reads a variable.\n- **Mutable Borrow (`&mut T`)**: If the closure modifies a variable.\n- **Ownership (`T`)**: If the closure takes ownership (e.g., via `move` or by consuming the variable).\n\nThe compiler automatically infers the least restrictive capture mode needed. The `move` keyword forces ownership capture, but the closure‚Äôs trait (`Fn`, `FnMut`, or `FnOnce`) depends on how the captured variables are used.\n\n## Closure Traits\n\nRust closures implement one or more of these traits:\n\n| Trait   | Captures Variables Via | Call Semantics | Call Count |\n|---------|------------------------|----------------|------------|\n| `Fn`    | Immutable borrow (`&T`) | `&self`        | Multiple   |\n| `FnMut` | Mutable borrow (`&mut T`) | `&mut self` | Multiple   |\n| `FnOnce`| Ownership (`T`)        | `self` (consumes closure) | Once |\n\n### Key Differences\n\n- **`Fn`**:\n  - Can be called repeatedly.\n  - Captures variables immutably.\n  - Example:\n    ```rust\n    let x = 42;\n    let closure = || println!(\"{}\", x); // Fn (captures `x` by &T)\n    ```\n\n- **`FnMut`**:\n  - Can mutate captured variables.\n  - Requires `mut` keyword if stored.\n  - Example:\n    ```rust\n    let mut x = 42;\n    let mut closure = || { x += 1; }; // FnMut (captures `x` by &mut T)\n    ```\n\n- **`FnOnce`**:\n  - Takes ownership of captured variables.\n  - Can only be called once.\n  - Example:\n    ```rust\n    let x = String::from(\"hello\");\n    let closure = || { drop(x); }; // FnOnce (moves `x` into closure)\n    ```\n\n## Trait Hierarchy\n\n- **`Fn`**: Also implements `FnMut` and `FnOnce`.\n- **`FnMut`**: Also implements `FnOnce`.\n- A closure that implements `Fn` can be used where `FnMut` or `FnOnce` is required.\n- A closure that implements `FnMut` can be used as `FnOnce`.\n\n## `move` Keyword\n\nForces the closure to take ownership of captured variables, even if they‚Äôre only read:\n```rust\nlet s = String::from(\"hello\");\nlet closure = move || println!(\"{}\", s); // `s` is moved into the closure\n```\n\n- **Trait Impact**:\n  - If the closure doesn‚Äôt mutate or consume `s`, it still implements `Fn` (since `s` is owned but not modified).\n  - If the closure consumes `s` (e.g., `drop(s)`), it becomes `FnOnce`.\n\n## Examples\n\n1. **Immutable Capture (`Fn`)**:\n   ```rust\n   let x = 5;\n   let print_x = || println!(\"{}\", x); // Fn\n   print_x(); // OK\n   print_x(); // Still valid\n   ```\n\n2. **Mutable Capture (`FnMut`)**:\n   ```rust\n   let mut x = 5;\n   let mut add_one = || x += 1; // FnMut\n   add_one(); // x = 6\n   add_one(); // x = 7\n   ```\n\n3. **Ownership Capture (`FnOnce`)**:\n   ```rust\n   let x = String::from(\"hello\");\n   let consume_x = || { drop(x); }; // FnOnce\n   consume_x(); // OK\n   // consume_x(); // ERROR: closure called after being moved\n   ```\n\n## Performance & Use Cases\n\n| Trait   | Overhead      | Use Case                        |\n|---------|---------------|---------------------------------|\n| `Fn`    | Zero-cost     | Read-only callbacks, iterators  |\n| `FnMut` | Zero-cost     | Stateful transformations       |\n| `FnOnce`| May allocate  | One-time operations (e.g., spawning threads) |\n\n## Key Takeaways\n\n‚úÖ **`Fn`**: Read-only, reusable.  \n‚úÖ **`FnMut`**: Mutable, reusable.  \n‚úÖ **`FnOnce`**: Owned, single-use.  \nüöÄ `move` forces ownership but doesn‚Äôt change the trait‚Äîusage determines the trait.\n\n**Try This:** What happens if a closure captures a mutable reference but doesn‚Äôt mutate it?  \n**Answer:** It still implements `FnMut` (since it *could* mutate), but you can pass it to a function expecting `FnMut`.",
    "contentHtml": "<p>Understanding the distinction between <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> traits is crucial for mastering Rust&#39;s closure system, ownership, and performance characteristics.</p>\n<h2>Closure Capturing</h2>\n<p>Closures in Rust capture variables from their environment in one of three ways, depending on how the variables are used:</p>\n<ul>\n<li><strong>Immutable Borrow (<code>&amp;T</code>)</strong>: If the closure only reads a variable.</li>\n<li><strong>Mutable Borrow (<code>&amp;mut T</code>)</strong>: If the closure modifies a variable.</li>\n<li><strong>Ownership (<code>T</code>)</strong>: If the closure takes ownership (e.g., via <code>move</code> or by consuming the variable).</li>\n</ul>\n<p>The compiler automatically infers the least restrictive capture mode needed. The <code>move</code> keyword forces ownership capture, but the closure‚Äôs trait (<code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>) depends on how the captured variables are used.</p>\n<h2>Closure Traits</h2>\n<p>Rust closures implement one or more of these traits:</p>\n<table>\n<thead>\n<tr>\n<th>Trait</th>\n<th>Captures Variables Via</th>\n<th>Call Semantics</th>\n<th>Call Count</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Fn</code></td>\n<td>Immutable borrow (<code>&amp;T</code>)</td>\n<td><code>&amp;self</code></td>\n<td>Multiple</td>\n</tr>\n<tr>\n<td><code>FnMut</code></td>\n<td>Mutable borrow (<code>&amp;mut T</code>)</td>\n<td><code>&amp;mut self</code></td>\n<td>Multiple</td>\n</tr>\n<tr>\n<td><code>FnOnce</code></td>\n<td>Ownership (<code>T</code>)</td>\n<td><code>self</code> (consumes closure)</td>\n<td>Once</td>\n</tr>\n</tbody></table>\n<h3>Key Differences</h3>\n<ul>\n<li><p><strong><code>Fn</code></strong>:</p>\n<ul>\n<li>Can be called repeatedly.</li>\n<li>Captures variables immutably.</li>\n<li>Example:<pre><code class=\"language-rust\">let x = 42;\nlet closure = || println!(&quot;{}&quot;, x); // Fn (captures `x` by &amp;T)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong><code>FnMut</code></strong>:</p>\n<ul>\n<li>Can mutate captured variables.</li>\n<li>Requires <code>mut</code> keyword if stored.</li>\n<li>Example:<pre><code class=\"language-rust\">let mut x = 42;\nlet mut closure = || { x += 1; }; // FnMut (captures `x` by &amp;mut T)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong><code>FnOnce</code></strong>:</p>\n<ul>\n<li>Takes ownership of captured variables.</li>\n<li>Can only be called once.</li>\n<li>Example:<pre><code class=\"language-rust\">let x = String::from(&quot;hello&quot;);\nlet closure = || { drop(x); }; // FnOnce (moves `x` into closure)\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Trait Hierarchy</h2>\n<ul>\n<li><strong><code>Fn</code></strong>: Also implements <code>FnMut</code> and <code>FnOnce</code>.</li>\n<li><strong><code>FnMut</code></strong>: Also implements <code>FnOnce</code>.</li>\n<li>A closure that implements <code>Fn</code> can be used where <code>FnMut</code> or <code>FnOnce</code> is required.</li>\n<li>A closure that implements <code>FnMut</code> can be used as <code>FnOnce</code>.</li>\n</ul>\n<h2><code>move</code> Keyword</h2>\n<p>Forces the closure to take ownership of captured variables, even if they‚Äôre only read:</p>\n<pre><code class=\"language-rust\">let s = String::from(&quot;hello&quot;);\nlet closure = move || println!(&quot;{}&quot;, s); // `s` is moved into the closure\n</code></pre>\n<ul>\n<li><strong>Trait Impact</strong>:<ul>\n<li>If the closure doesn‚Äôt mutate or consume <code>s</code>, it still implements <code>Fn</code> (since <code>s</code> is owned but not modified).</li>\n<li>If the closure consumes <code>s</code> (e.g., <code>drop(s)</code>), it becomes <code>FnOnce</code>.</li>\n</ul>\n</li>\n</ul>\n<h2>Examples</h2>\n<ol>\n<li><p><strong>Immutable Capture (<code>Fn</code>)</strong>:</p>\n<pre><code class=\"language-rust\">let x = 5;\nlet print_x = || println!(&quot;{}&quot;, x); // Fn\nprint_x(); // OK\nprint_x(); // Still valid\n</code></pre>\n</li>\n<li><p><strong>Mutable Capture (<code>FnMut</code>)</strong>:</p>\n<pre><code class=\"language-rust\">let mut x = 5;\nlet mut add_one = || x += 1; // FnMut\nadd_one(); // x = 6\nadd_one(); // x = 7\n</code></pre>\n</li>\n<li><p><strong>Ownership Capture (<code>FnOnce</code>)</strong>:</p>\n<pre><code class=\"language-rust\">let x = String::from(&quot;hello&quot;);\nlet consume_x = || { drop(x); }; // FnOnce\nconsume_x(); // OK\n// consume_x(); // ERROR: closure called after being moved\n</code></pre>\n</li>\n</ol>\n<h2>Performance &amp; Use Cases</h2>\n<table>\n<thead>\n<tr>\n<th>Trait</th>\n<th>Overhead</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Fn</code></td>\n<td>Zero-cost</td>\n<td>Read-only callbacks, iterators</td>\n</tr>\n<tr>\n<td><code>FnMut</code></td>\n<td>Zero-cost</td>\n<td>Stateful transformations</td>\n</tr>\n<tr>\n<td><code>FnOnce</code></td>\n<td>May allocate</td>\n<td>One-time operations (e.g., spawning threads)</td>\n</tr>\n</tbody></table>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong><code>Fn</code></strong>: Read-only, reusable.<br>‚úÖ <strong><code>FnMut</code></strong>: Mutable, reusable.<br>‚úÖ <strong><code>FnOnce</code></strong>: Owned, single-use.<br>üöÄ <code>move</code> forces ownership but doesn‚Äôt change the trait‚Äîusage determines the trait.</p>\n<p><strong>Try This:</strong> What happens if a closure captures a mutable reference but doesn‚Äôt mutate it?<br><strong>Answer:</strong> It still implements <code>FnMut</code> (since it <em>could</em> mutate), but you can pass it to a function expecting <code>FnMut</code>.</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "closures",
      "traits",
      "ownership",
      "lifetimes"
    ],
    "readingTime": "3 min",
    "seo": {
      "title": "What are the differences between Fn, FnMut, and FnOnce?",
      "description": "Functions and closures in Rust, covering ownership, traits, lifetimes",
      "keywords": [
        "rust",
        "closures",
        "traits",
        "ownership",
        "lifetimes"
      ]
    },
    "headings": [
      {
        "id": "closure-capturing",
        "text": "Closure Capturing",
        "level": 2
      },
      {
        "id": "closure-traits",
        "text": "Closure Traits",
        "level": 2
      },
      {
        "id": "key-differences",
        "text": "Key Differences",
        "level": 3
      },
      {
        "id": "trait-hierarchy",
        "text": "Trait Hierarchy",
        "level": 2
      },
      {
        "id": "move-keyword",
        "text": "`move` Keyword",
        "level": 2
      },
      {
        "id": "examples",
        "text": "Examples",
        "level": 2
      },
      {
        "id": "performance-and-use-cases",
        "text": "Performance & Use Cases",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "closure-parameter-rust",
    "slug": "closure-parameter-rust",
    "title": "How do you specify a closure as a function parameter or return type?",
    "date": "2025-07-07",
    "excerpt": "Functions and closures in Rust, covering ownership, traits, lifetimes",
    "content": "Closures in Rust are anonymous types, so you must use trait bounds (`Fn`, `FnMut`, `FnOnce`) to define their signatures. Here‚Äôs how to work with them as parameters and return types.\n\n## Closure as a Function Parameter\n\nUse generic type parameters with trait bounds to accept closures.\n\n### Example: `Fn` (Immutable Borrow)\n\n```rust\n// Accepts a closure that takes `i32` and returns `i32` (read-only).\nfn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {\n    f(x)\n}\n\nfn main() {\n    let add_five = |x| x + 5; // Implements `Fn`\n    println!(\"{}\", apply(add_five, 10)); // 15\n}\n```\n\n### Example: `FnMut` (Mutable Borrow)\n\n```rust\n// Accepts a closure that mutates its environment.\nfn apply_mut<F: FnMut(i32) -> i32>(mut f: F, x: i32) -> i32 {\n    f(x)\n}\n\nfn main() {\n    let mut count = 0;\n    let mut increment_and_add = |x| {\n        count += 1; // Mutates `count` ‚Üí `FnMut`\n        x + count\n    };\n    println!(\"{}\", apply_mut(increment_and_add, 10)); // 11\n}\n```\n\n## Closure as a Return Type\n\nUse `impl Trait` for static dispatch (zero-cost) or `Box<dyn Trait>` for dynamic dispatch (flexible).\n\n### Example: Return `impl Fn` (Static Dispatch)\n\n```rust\n// Returns a closure that adds a fixed value (immutable capture).\nfn make_adder(a: i32) -> impl Fn(i32) -> i32 {\n    move |b| a + b // `move` forces ownership (still `Fn` since `a` is read-only)\n}\n\nfn main() {\n    let add_ten = make_adder(10);\n    println!(\"{}\", add_ten(5)); // 15\n}\n```\n\n### Example: Return `Box<dyn Fn>` (Dynamic Dispatch)\n\n```rust\n// Returns a trait object for heterogeneous closures.\nfn create_closure(is_add: bool) -> Box<dyn Fn(i32) -> i32> {\n    if is_add {\n        Box::new(|x| x + 1) // Heap-allocated closure\n    } else {\n        Box::new(|x| x - 1)\n    }\n}\n\nfn main() {\n    let add = create_closure(true);\n    let sub = create_closure(false);\n    println!(\"{} {}\", add(5), sub(5)); // 6 4\n}\n```\n\n## Key Differences\n\n| Approach            | `impl Fn` (Static)         | `Box<dyn Fn>` (Dynamic)    |\n|---------------------|----------------------------|----------------------------|\n| **Dispatch**        | Monomorphized (zero-cost)  | Vtable lookup (runtime cost) |\n| **Use Case**        | Single closure type        | Multiple closure types     |\n| **Memory**          | Stack-allocated            | Heap-allocated (trait object) |\n| **Flexibility**     | Less (fixed type)          | More (any `dyn Fn` closure) |\n\n## When to Use Each\n\n- **`impl Fn`**:\n  - When returning a single type of closure (e.g., from a factory function).\n  - For performance-critical code (no heap allocation).\n\n- **`Box<dyn Fn>`**:\n  - When returning different closure types (e.g., conditionally).\n  - For dynamic behavior (e.g., plugin systems, callbacks).\n\n## Pitfalls\n\n- **`FnMut` in Structs**: Store mutable closures with `FnMut` and annotate `mut`:\n  ```rust\n  struct Processor<F: FnMut(i32) -> i32> {\n      op: F,\n  }\n  ```\n\n- **Lifetimes**: Closures capturing references may require explicit lifetimes:\n  ```rust\n  fn capture_ref<'a>(s: &'a str) -> impl Fn() -> &'a str {\n      move || s // Closure captures `s` with lifetime `'a`\n  }\n  ```\n\n## Key Takeaways\n\n‚úÖ **Parameter**: Use generics (`F: Fn(...)`) for flexibility and performance.  \n‚úÖ **Return Type**:  \n- `impl Fn` for static dispatch (fast, fixed type).  \n- `Box<dyn Fn>` for dynamic dispatch (flexible, multiple types).  \nüöÄ Prefer `impl Fn` unless you need runtime polymorphism.\n\n**Try This**: What happens if you return a `FnOnce` closure?  \n**Answer**: It‚Äôs allowed, but the caller can only invoke it once!",
    "contentHtml": "<p>Closures in Rust are anonymous types, so you must use trait bounds (<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>) to define their signatures. Here‚Äôs how to work with them as parameters and return types.</p>\n<h2>Closure as a Function Parameter</h2>\n<p>Use generic type parameters with trait bounds to accept closures.</p>\n<h3>Example: <code>Fn</code> (Immutable Borrow)</h3>\n<pre><code class=\"language-rust\">// Accepts a closure that takes `i32` and returns `i32` (read-only).\nfn apply&lt;F: Fn(i32) -&gt; i32&gt;(f: F, x: i32) -&gt; i32 {\n    f(x)\n}\n\nfn main() {\n    let add_five = |x| x + 5; // Implements `Fn`\n    println!(&quot;{}&quot;, apply(add_five, 10)); // 15\n}\n</code></pre>\n<h3>Example: <code>FnMut</code> (Mutable Borrow)</h3>\n<pre><code class=\"language-rust\">// Accepts a closure that mutates its environment.\nfn apply_mut&lt;F: FnMut(i32) -&gt; i32&gt;(mut f: F, x: i32) -&gt; i32 {\n    f(x)\n}\n\nfn main() {\n    let mut count = 0;\n    let mut increment_and_add = |x| {\n        count += 1; // Mutates `count` ‚Üí `FnMut`\n        x + count\n    };\n    println!(&quot;{}&quot;, apply_mut(increment_and_add, 10)); // 11\n}\n</code></pre>\n<h2>Closure as a Return Type</h2>\n<p>Use <code>impl Trait</code> for static dispatch (zero-cost) or <code>Box&lt;dyn Trait&gt;</code> for dynamic dispatch (flexible).</p>\n<h3>Example: Return <code>impl Fn</code> (Static Dispatch)</h3>\n<pre><code class=\"language-rust\">// Returns a closure that adds a fixed value (immutable capture).\nfn make_adder(a: i32) -&gt; impl Fn(i32) -&gt; i32 {\n    move |b| a + b // `move` forces ownership (still `Fn` since `a` is read-only)\n}\n\nfn main() {\n    let add_ten = make_adder(10);\n    println!(&quot;{}&quot;, add_ten(5)); // 15\n}\n</code></pre>\n<h3>Example: Return <code>Box&lt;dyn Fn&gt;</code> (Dynamic Dispatch)</h3>\n<pre><code class=\"language-rust\">// Returns a trait object for heterogeneous closures.\nfn create_closure(is_add: bool) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {\n    if is_add {\n        Box::new(|x| x + 1) // Heap-allocated closure\n    } else {\n        Box::new(|x| x - 1)\n    }\n}\n\nfn main() {\n    let add = create_closure(true);\n    let sub = create_closure(false);\n    println!(&quot;{} {}&quot;, add(5), sub(5)); // 6 4\n}\n</code></pre>\n<h2>Key Differences</h2>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th><code>impl Fn</code> (Static)</th>\n<th><code>Box&lt;dyn Fn&gt;</code> (Dynamic)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Dispatch</strong></td>\n<td>Monomorphized (zero-cost)</td>\n<td>Vtable lookup (runtime cost)</td>\n</tr>\n<tr>\n<td><strong>Use Case</strong></td>\n<td>Single closure type</td>\n<td>Multiple closure types</td>\n</tr>\n<tr>\n<td><strong>Memory</strong></td>\n<td>Stack-allocated</td>\n<td>Heap-allocated (trait object)</td>\n</tr>\n<tr>\n<td><strong>Flexibility</strong></td>\n<td>Less (fixed type)</td>\n<td>More (any <code>dyn Fn</code> closure)</td>\n</tr>\n</tbody></table>\n<h2>When to Use Each</h2>\n<ul>\n<li><p><strong><code>impl Fn</code></strong>:</p>\n<ul>\n<li>When returning a single type of closure (e.g., from a factory function).</li>\n<li>For performance-critical code (no heap allocation).</li>\n</ul>\n</li>\n<li><p><strong><code>Box&lt;dyn Fn&gt;</code></strong>:</p>\n<ul>\n<li>When returning different closure types (e.g., conditionally).</li>\n<li>For dynamic behavior (e.g., plugin systems, callbacks).</li>\n</ul>\n</li>\n</ul>\n<h2>Pitfalls</h2>\n<ul>\n<li><p><strong><code>FnMut</code> in Structs</strong>: Store mutable closures with <code>FnMut</code> and annotate <code>mut</code>:</p>\n<pre><code class=\"language-rust\">struct Processor&lt;F: FnMut(i32) -&gt; i32&gt; {\n    op: F,\n}\n</code></pre>\n</li>\n<li><p><strong>Lifetimes</strong>: Closures capturing references may require explicit lifetimes:</p>\n<pre><code class=\"language-rust\">fn capture_ref&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; impl Fn() -&gt; &amp;&#39;a str {\n    move || s // Closure captures `s` with lifetime `&#39;a`\n}\n</code></pre>\n</li>\n</ul>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong>Parameter</strong>: Use generics (<code>F: Fn(...)</code>) for flexibility and performance.<br>‚úÖ <strong>Return Type</strong>:  </p>\n<ul>\n<li><code>impl Fn</code> for static dispatch (fast, fixed type).  </li>\n<li><code>Box&lt;dyn Fn&gt;</code> for dynamic dispatch (flexible, multiple types).<br>üöÄ Prefer <code>impl Fn</code> unless you need runtime polymorphism.</li>\n</ul>\n<p><strong>Try This</strong>: What happens if you return a <code>FnOnce</code> closure?<br><strong>Answer</strong>: It‚Äôs allowed, but the caller can only invoke it once!</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "closures",
      "traits",
      "ownership",
      "lifetimes"
    ],
    "readingTime": "3 min",
    "seo": {
      "title": "How do you specify a closure as a function parameter or return type?",
      "description": "Functions and closures in Rust, covering ownership, traits, lifetimes",
      "keywords": [
        "rust",
        "closures",
        "traits",
        "ownership",
        "lifetimes"
      ]
    },
    "headings": [
      {
        "id": "closure-as-a-function-parameter",
        "text": "Closure as a Function Parameter",
        "level": 2
      },
      {
        "id": "example-fn-immutable-borrow",
        "text": "Example: `Fn` (Immutable Borrow)",
        "level": 3
      },
      {
        "id": "example-fnmut-mutable-borrow",
        "text": "Example: `FnMut` (Mutable Borrow)",
        "level": 3
      },
      {
        "id": "closure-as-a-return-type",
        "text": "Closure as a Return Type",
        "level": 2
      },
      {
        "id": "example-return-impl-fn-static-dispatch",
        "text": "Example: Return `impl Fn` (Static Dispatch)",
        "level": 3
      },
      {
        "id": "example-return-boxlessdyn-fngreater-dynamic-dispatch",
        "text": "Example: Return `Box<dyn Fn>` (Dynamic Dispatch)",
        "level": 3
      },
      {
        "id": "key-differences",
        "text": "Key Differences",
        "level": 2
      },
      {
        "id": "when-to-use-each",
        "text": "When to Use Each",
        "level": 2
      },
      {
        "id": "pitfalls",
        "text": "Pitfalls",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "rust-traits-vs-interfaces",
    "slug": "rust-traits-vs-interfaces",
    "title": "Rust Traits vs. Java/C# Interfaces: Shared Behavior Done Right",
    "date": "2025-07-04",
    "excerpt": "Discussion on Rust traits vs Java/C# interfaces, covering dispatch mechanisms, compile-time behavior, and performance optimizations.",
    "content": "Rust traits and interfaces both define shared behavior, but differ fundamentally in design and execution, especially in performance-critical contexts.\n\n## Key Differences\n\n| Aspect | Rust Traits | Java/C# Interfaces |\n|--------|-------------|-------------------|\n| **Dispatch** | Static dispatch (generics) by default, opt-in dynamic (`dyn`) | Runtime polymorphism via vtables |\n| **Implementation** | Explicit via `impl Trait for Type` | Implicit (C#) or explicit (Java) |\n| **Compile-time** | Resolved at compile time via monomorphization | Runtime constructs with JIT optimization |\n| **Inheritance** | No inheritance; composition via supertraits | Interface inheritance with runtime checks |\n| **Performance** | Zero-cost abstraction, inlining enabled | 1-2 cycle dispatch cost, limited inlining |\n\n## Implementation and Dispatch\n\n**Rust Traits**: Support static dispatch via generics where the compiler monomorphizes code for each type, inlining calls for zero runtime overhead. Dynamic dispatch (`dyn Trait`) uses vtables but is opt-in.\n\n**Java/C# Interfaces**: Rely on runtime polymorphism via vtables, incurring dispatch costs and preventing inlining across type boundaries.\n\n## Example: Performance-Critical Networking Stack\n\nDefine a `PacketHandler` trait for efficient packet processing across different protocols:\n\n```rust\ntrait PacketHandler {\n    fn process(&mut self, data: &[u8]) -> usize; // Bytes processed\n    fn reset(&mut self); // Reset state\n}\n\nstruct TcpHandler { state: u32 }\nstruct UdpHandler { count: u16 }\n\nimpl PacketHandler for TcpHandler {\n    fn process(&mut self, data: &[u8]) -> usize {\n        self.state = data.iter().fold(self.state, |acc, &x| acc.wrapping_add(x as u32));\n        data.len()\n    }\n    fn reset(&mut self) { self.state = 0; }\n}\n\nimpl PacketHandler for UdpHandler {\n    fn process(&mut self, data: &[u8]) -> usize {\n        self.count = self.count.wrapping_add(1);\n        data.len()\n    }\n    fn reset(&mut self) { self.count = 0; }\n}\n\nfn process_packets<H: PacketHandler>(handler: &mut H, packets: &[&[u8]]) -> usize {\n    let mut total = 0;\n    for packet in packets {\n        total += handler.process(packet);\n    }\n    total\n}\n```\n\nUsage:\n```rust\nlet mut tcp = TcpHandler { state: 0 };\nlet packets = vec![&[1, 2, 3], &[4, 5, 6]];\nlet bytes = process_packets(&mut tcp, &packets); // Static dispatch\n```\n\n## How It Enhances Performance and Safety\n\n### Performance\n\n- **Static Dispatch**: `process_packets` monomorphizes for `TcpHandler` and `UdpHandler`, generating separate, inlined code paths. No vtable lookups, saving cycles in hot loops\n- **Inlining**: Compiler can inline `process` calls, fusing them with the loop, reducing branches and enabling SIMD optimizations\n- **Zero-Cost**: Trait abstraction adds no runtime overhead‚Äîequivalent to hand-writing `process_tcp` and `process_udp`\n\n### Safety\n\n- **Type Safety**: Trait bound `H: PacketHandler` ensures only compatible types are passed, checked at compile time‚Äîno runtime casts like Java's `instanceof`\n- **Encapsulation**: Each handler manages its state (`state` or `count`), with Rust's ownership enforcing mutation rules\n\n## Contrast with Java/C#\n\nJava equivalent:\n```java\ninterface PacketHandler {\n    int process(byte[] data);\n    void reset();\n}\n\nclass TcpHandler implements PacketHandler {\n    // vtable-based dispatch, no inlining across types\n}\n```\n\nEvery `process` call goes through a vtable, preventing loop fusion and adding indirection. Rust's static dispatch avoids this‚Äîcritical for networking stacks handling millions of packets per second.\n\n## Advanced Considerations\n\n- **Associated Types**: Enable type-level constraints without runtime overhead\n- **Default Implementations**: Reduce boilerplate while maintaining zero-cost\n- **Supertraits**: Compose behavior without inheritance complexity\n- **Dynamic Dispatch**: Use `Box<dyn PacketHandler>` when type erasure is needed\n\n## Key Takeaways\n\n‚úÖ **Rust traits**: Compile-time resolution, zero-cost abstraction, static dispatch by default  \n‚úÖ **Java/C# interfaces**: Runtime polymorphism, vtable overhead, dynamic by nature  \nüöÄ Use traits for performance-critical code where static dispatch eliminates overhead\n\n**Try This:** What happens if you use `&dyn PacketHandler` instead of generics?  \n**Answer:** You get dynamic dispatch with vtable overhead‚Äîmeasure the performance difference in your hot paths!",
    "contentHtml": "<p>Rust traits and interfaces both define shared behavior, but differ fundamentally in design and execution, especially in performance-critical contexts.</p>\n<h2>Key Differences</h2>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Rust Traits</th>\n<th>Java/C# Interfaces</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Dispatch</strong></td>\n<td>Static dispatch (generics) by default, opt-in dynamic (<code>dyn</code>)</td>\n<td>Runtime polymorphism via vtables</td>\n</tr>\n<tr>\n<td><strong>Implementation</strong></td>\n<td>Explicit via <code>impl Trait for Type</code></td>\n<td>Implicit (C#) or explicit (Java)</td>\n</tr>\n<tr>\n<td><strong>Compile-time</strong></td>\n<td>Resolved at compile time via monomorphization</td>\n<td>Runtime constructs with JIT optimization</td>\n</tr>\n<tr>\n<td><strong>Inheritance</strong></td>\n<td>No inheritance; composition via supertraits</td>\n<td>Interface inheritance with runtime checks</td>\n</tr>\n<tr>\n<td><strong>Performance</strong></td>\n<td>Zero-cost abstraction, inlining enabled</td>\n<td>1-2 cycle dispatch cost, limited inlining</td>\n</tr>\n</tbody></table>\n<h2>Implementation and Dispatch</h2>\n<p><strong>Rust Traits</strong>: Support static dispatch via generics where the compiler monomorphizes code for each type, inlining calls for zero runtime overhead. Dynamic dispatch (<code>dyn Trait</code>) uses vtables but is opt-in.</p>\n<p><strong>Java/C# Interfaces</strong>: Rely on runtime polymorphism via vtables, incurring dispatch costs and preventing inlining across type boundaries.</p>\n<h2>Example: Performance-Critical Networking Stack</h2>\n<p>Define a <code>PacketHandler</code> trait for efficient packet processing across different protocols:</p>\n<pre><code class=\"language-rust\">trait PacketHandler {\n    fn process(&amp;mut self, data: &amp;[u8]) -&gt; usize; // Bytes processed\n    fn reset(&amp;mut self); // Reset state\n}\n\nstruct TcpHandler { state: u32 }\nstruct UdpHandler { count: u16 }\n\nimpl PacketHandler for TcpHandler {\n    fn process(&amp;mut self, data: &amp;[u8]) -&gt; usize {\n        self.state = data.iter().fold(self.state, |acc, &amp;x| acc.wrapping_add(x as u32));\n        data.len()\n    }\n    fn reset(&amp;mut self) { self.state = 0; }\n}\n\nimpl PacketHandler for UdpHandler {\n    fn process(&amp;mut self, data: &amp;[u8]) -&gt; usize {\n        self.count = self.count.wrapping_add(1);\n        data.len()\n    }\n    fn reset(&amp;mut self) { self.count = 0; }\n}\n\nfn process_packets&lt;H: PacketHandler&gt;(handler: &amp;mut H, packets: &amp;[&amp;[u8]]) -&gt; usize {\n    let mut total = 0;\n    for packet in packets {\n        total += handler.process(packet);\n    }\n    total\n}\n</code></pre>\n<p>Usage:</p>\n<pre><code class=\"language-rust\">let mut tcp = TcpHandler { state: 0 };\nlet packets = vec![&amp;[1, 2, 3], &amp;[4, 5, 6]];\nlet bytes = process_packets(&amp;mut tcp, &amp;packets); // Static dispatch\n</code></pre>\n<h2>How It Enhances Performance and Safety</h2>\n<h3>Performance</h3>\n<ul>\n<li><strong>Static Dispatch</strong>: <code>process_packets</code> monomorphizes for <code>TcpHandler</code> and <code>UdpHandler</code>, generating separate, inlined code paths. No vtable lookups, saving cycles in hot loops</li>\n<li><strong>Inlining</strong>: Compiler can inline <code>process</code> calls, fusing them with the loop, reducing branches and enabling SIMD optimizations</li>\n<li><strong>Zero-Cost</strong>: Trait abstraction adds no runtime overhead‚Äîequivalent to hand-writing <code>process_tcp</code> and <code>process_udp</code></li>\n</ul>\n<h3>Safety</h3>\n<ul>\n<li><strong>Type Safety</strong>: Trait bound <code>H: PacketHandler</code> ensures only compatible types are passed, checked at compile time‚Äîno runtime casts like Java&#39;s <code>instanceof</code></li>\n<li><strong>Encapsulation</strong>: Each handler manages its state (<code>state</code> or <code>count</code>), with Rust&#39;s ownership enforcing mutation rules</li>\n</ul>\n<h2>Contrast with Java/C#</h2>\n<p>Java equivalent:</p>\n<pre><code class=\"language-java\">interface PacketHandler {\n    int process(byte[] data);\n    void reset();\n}\n\nclass TcpHandler implements PacketHandler {\n    // vtable-based dispatch, no inlining across types\n}\n</code></pre>\n<p>Every <code>process</code> call goes through a vtable, preventing loop fusion and adding indirection. Rust&#39;s static dispatch avoids this‚Äîcritical for networking stacks handling millions of packets per second.</p>\n<h2>Advanced Considerations</h2>\n<ul>\n<li><strong>Associated Types</strong>: Enable type-level constraints without runtime overhead</li>\n<li><strong>Default Implementations</strong>: Reduce boilerplate while maintaining zero-cost</li>\n<li><strong>Supertraits</strong>: Compose behavior without inheritance complexity</li>\n<li><strong>Dynamic Dispatch</strong>: Use <code>Box&lt;dyn PacketHandler&gt;</code> when type erasure is needed</li>\n</ul>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong>Rust traits</strong>: Compile-time resolution, zero-cost abstraction, static dispatch by default<br>‚úÖ <strong>Java/C# interfaces</strong>: Runtime polymorphism, vtable overhead, dynamic by nature<br>üöÄ Use traits for performance-critical code where static dispatch eliminates overhead</p>\n<p><strong>Try This:</strong> What happens if you use <code>&amp;dyn PacketHandler</code> instead of generics?<br><strong>Answer:</strong> You get dynamic dispatch with vtable overhead‚Äîmeasure the performance difference in your hot paths!</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "traits",
      "performance",
      "interfaces",
      "dispatch"
    ],
    "readingTime": "4 min",
    "seo": {
      "title": "Rust Traits vs. Java/C# Interfaces: Shared Behavior Done Right",
      "description": "Discussion on Rust traits vs Java/C# interfaces, covering dispatch mechanisms, compile-time behavior, and performance optimizations.",
      "keywords": [
        "rust",
        "traits",
        "performance",
        "interfaces",
        "dispatch"
      ]
    },
    "headings": [
      {
        "id": "key-differences",
        "text": "Key Differences",
        "level": 2
      },
      {
        "id": "implementation-and-dispatch",
        "text": "Implementation and Dispatch",
        "level": 2
      },
      {
        "id": "example-performance-critical-networking-stack",
        "text": "Example: Performance-Critical Networking Stack",
        "level": 2
      },
      {
        "id": "how-it-enhances-performance-and-safety",
        "text": "How It Enhances Performance and Safety",
        "level": 2
      },
      {
        "id": "performance",
        "text": "Performance",
        "level": 3
      },
      {
        "id": "safety",
        "text": "Safety",
        "level": 3
      },
      {
        "id": "contrast-with-javac",
        "text": "Contrast with Java/C#",
        "level": 2
      },
      {
        "id": "advanced-considerations",
        "text": "Advanced Considerations",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "string-vs-str-rust",
    "slug": "string-vs-str-rust",
    "title": "String vs. &str ‚Äì Which to Use and When?",
    "date": "2025-07-03",
    "excerpt": "String vs str in Rust, covering memory management, ownership, and when to use each type.",
    "content": "Understanding the distinction between `String` and `str` is fundamental to effective memory management and ownership in Rust.\n\n## Key Differences\n\n| `String` | `str` (usually `&str`) |\n|----------|------------------------|\n| Growable, heap-allocated UTF-8 string | Immutable, fixed-size view into UTF-8 string |\n| Owned type (manages its memory) | Borrowed type (does not own memory) |\n| Mutable (can modify content) | Immutable view |\n| Created using `String::from(\"...\")` or `\"...\".to_string()` | From string literals (`\"hello\"`) or borrowed from `String` (`&my_string`) |\n\n## Memory Layout\n\n**`String`**: Stores data on the heap with three components:\n- Pointer to heap buffer\n- Length (current size)\n- Capacity (allocated size)\n\n**`&str`**: A \"fat pointer\" containing:\n- Pointer to string data (heap, stack, or static memory)\n- Length of the slice\n\n## When to Use Each\n\nUse **`String`** when:\n- You need to modify or grow the string\n- You need ownership (e.g., returning from a function)\n- Building strings dynamically\n\n```rust\nlet mut owned = String::from(\"hello\");\nowned.push_str(\" world\");  // Mutation requires String\n```\n\nUse **`&str`** when:\n- You only need a read-only view of a string\n- Working with function parameters (avoids unnecessary allocations)\n- Handling string literals (stored in read-only memory)\n\n```rust\nfn process_str(s: &str) -> usize {\n    s.len()  // Read-only access\n}\n```\n\n## Example: Ownership vs Borrowing\n\n```rust\nfn process_string(s: String) { /* takes ownership */ }\nfn process_str(s: &str)      { /* borrows */ }\n\nfn main() {\n    let heap_str = String::from(\"hello\");\n    let static_str = \"world\";\n    \n    process_string(heap_str);  // Ownership moved\n    process_str(static_str);   // Borrowed\n    \n    // heap_str no longer accessible here\n    // static_str still accessible\n}\n```\n\n## Performance Considerations\n\n**Function Parameters**:\n```rust\n// Inefficient - forces allocation\nfn bad(s: String) -> usize { s.len() }\n\n// Efficient - accepts both String and &str\nfn good(s: &str) -> usize { s.len() }\n\n// Usage\nlet owned = String::from(\"test\");\ngood(&owned);  // Deref coercion: String -> &str\ngood(\"literal\");  // Direct &str\n```\n\n**Memory Allocation**:\n- `String` allocates on heap, requires deallocation\n- `&str` to literals points to program binary (zero allocation)\n- `&str` from `String` shares existing allocation\n\n## Common Patterns\n\n**Return Owned Data**:\n```rust\nfn build_message(name: &str) -> String {\n    format!(\"Hello, {}!\", name)  // Returns owned String\n}\n```\n\n**Accept Flexible Input**:\n```rust\nfn analyze(text: &str) -> Analysis {\n    // Works with both String and &str inputs\n    text.chars().count()\n}\n```\n\n**Avoid Unnecessary Clones**:\n```rust\n// Bad - unnecessary allocation\nfn process_bad(s: &str) -> String {\n    s.to_string()  // Only if you actually need owned data\n}\n\n// Good - work with borrowed data when possible\nfn process_good(s: &str) -> &str {\n    s.trim()  // Returns slice of original\n}\n```\n\n## Key Takeaways\n\n‚úÖ **`String`**: Owned, mutable, heap-allocated  \n‚úÖ **`str`**: Borrowed, immutable, flexible (heap/stack/static)  \nüöÄ Prefer `&str` for function parameters unless you need ownership or mutation\n\n**Try This:** What happens when you call `.to_string()` on a string literal vs a `String`?  \n**Answer:** Literal creates new heap allocation; `String` creates a clone of existing heap data‚Äîboth allocate, but the source differs!",
    "contentHtml": "<p>Understanding the distinction between <code>String</code> and <code>str</code> is fundamental to effective memory management and ownership in Rust.</p>\n<h2>Key Differences</h2>\n<table>\n<thead>\n<tr>\n<th><code>String</code></th>\n<th><code>str</code> (usually <code>&amp;str</code>)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Growable, heap-allocated UTF-8 string</td>\n<td>Immutable, fixed-size view into UTF-8 string</td>\n</tr>\n<tr>\n<td>Owned type (manages its memory)</td>\n<td>Borrowed type (does not own memory)</td>\n</tr>\n<tr>\n<td>Mutable (can modify content)</td>\n<td>Immutable view</td>\n</tr>\n<tr>\n<td>Created using <code>String::from(&quot;...&quot;)</code> or <code>&quot;...&quot;.to_string()</code></td>\n<td>From string literals (<code>&quot;hello&quot;</code>) or borrowed from <code>String</code> (<code>&amp;my_string</code>)</td>\n</tr>\n</tbody></table>\n<h2>Memory Layout</h2>\n<p><strong><code>String</code></strong>: Stores data on the heap with three components:</p>\n<ul>\n<li>Pointer to heap buffer</li>\n<li>Length (current size)</li>\n<li>Capacity (allocated size)</li>\n</ul>\n<p><strong><code>&amp;str</code></strong>: A &quot;fat pointer&quot; containing:</p>\n<ul>\n<li>Pointer to string data (heap, stack, or static memory)</li>\n<li>Length of the slice</li>\n</ul>\n<h2>When to Use Each</h2>\n<p>Use <strong><code>String</code></strong> when:</p>\n<ul>\n<li>You need to modify or grow the string</li>\n<li>You need ownership (e.g., returning from a function)</li>\n<li>Building strings dynamically</li>\n</ul>\n<pre><code class=\"language-rust\">let mut owned = String::from(&quot;hello&quot;);\nowned.push_str(&quot; world&quot;);  // Mutation requires String\n</code></pre>\n<p>Use <strong><code>&amp;str</code></strong> when:</p>\n<ul>\n<li>You only need a read-only view of a string</li>\n<li>Working with function parameters (avoids unnecessary allocations)</li>\n<li>Handling string literals (stored in read-only memory)</li>\n</ul>\n<pre><code class=\"language-rust\">fn process_str(s: &amp;str) -&gt; usize {\n    s.len()  // Read-only access\n}\n</code></pre>\n<h2>Example: Ownership vs Borrowing</h2>\n<pre><code class=\"language-rust\">fn process_string(s: String) { /* takes ownership */ }\nfn process_str(s: &amp;str)      { /* borrows */ }\n\nfn main() {\n    let heap_str = String::from(&quot;hello&quot;);\n    let static_str = &quot;world&quot;;\n    \n    process_string(heap_str);  // Ownership moved\n    process_str(static_str);   // Borrowed\n    \n    // heap_str no longer accessible here\n    // static_str still accessible\n}\n</code></pre>\n<h2>Performance Considerations</h2>\n<p><strong>Function Parameters</strong>:</p>\n<pre><code class=\"language-rust\">// Inefficient - forces allocation\nfn bad(s: String) -&gt; usize { s.len() }\n\n// Efficient - accepts both String and &amp;str\nfn good(s: &amp;str) -&gt; usize { s.len() }\n\n// Usage\nlet owned = String::from(&quot;test&quot;);\ngood(&amp;owned);  // Deref coercion: String -&gt; &amp;str\ngood(&quot;literal&quot;);  // Direct &amp;str\n</code></pre>\n<p><strong>Memory Allocation</strong>:</p>\n<ul>\n<li><code>String</code> allocates on heap, requires deallocation</li>\n<li><code>&amp;str</code> to literals points to program binary (zero allocation)</li>\n<li><code>&amp;str</code> from <code>String</code> shares existing allocation</li>\n</ul>\n<h2>Common Patterns</h2>\n<p><strong>Return Owned Data</strong>:</p>\n<pre><code class=\"language-rust\">fn build_message(name: &amp;str) -&gt; String {\n    format!(&quot;Hello, {}!&quot;, name)  // Returns owned String\n}\n</code></pre>\n<p><strong>Accept Flexible Input</strong>:</p>\n<pre><code class=\"language-rust\">fn analyze(text: &amp;str) -&gt; Analysis {\n    // Works with both String and &amp;str inputs\n    text.chars().count()\n}\n</code></pre>\n<p><strong>Avoid Unnecessary Clones</strong>:</p>\n<pre><code class=\"language-rust\">// Bad - unnecessary allocation\nfn process_bad(s: &amp;str) -&gt; String {\n    s.to_string()  // Only if you actually need owned data\n}\n\n// Good - work with borrowed data when possible\nfn process_good(s: &amp;str) -&gt; &amp;str {\n    s.trim()  // Returns slice of original\n}\n</code></pre>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong><code>String</code></strong>: Owned, mutable, heap-allocated<br>‚úÖ <strong><code>str</code></strong>: Borrowed, immutable, flexible (heap/stack/static)<br>üöÄ Prefer <code>&amp;str</code> for function parameters unless you need ownership or mutation</p>\n<p><strong>Try This:</strong> What happens when you call <code>.to_string()</code> on a string literal vs a <code>String</code>?<br><strong>Answer:</strong> Literal creates new heap allocation; <code>String</code> creates a clone of existing heap data‚Äîboth allocate, but the source differs!</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "string",
      "memory",
      "ownership",
      "types"
    ],
    "readingTime": "3 min",
    "seo": {
      "title": "String vs. &str ‚Äì Which to Use and When?",
      "description": "String vs str in Rust, covering memory management, ownership, and when to use each type.",
      "keywords": [
        "rust",
        "string",
        "memory",
        "ownership",
        "types"
      ]
    },
    "headings": [
      {
        "id": "key-differences",
        "text": "Key Differences",
        "level": 2
      },
      {
        "id": "memory-layout",
        "text": "Memory Layout",
        "level": 2
      },
      {
        "id": "when-to-use-each",
        "text": "When to Use Each",
        "level": 2
      },
      {
        "id": "example-ownership-vs-borrowing",
        "text": "Example: Ownership vs Borrowing",
        "level": 2
      },
      {
        "id": "performance-considerations",
        "text": "Performance Considerations",
        "level": 2
      },
      {
        "id": "common-patterns",
        "text": "Common Patterns",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "function-vs-closure-rust",
    "slug": "function-vs-closure-rust",
    "title": "Functions or Closures in Rust? Know the Difference!",
    "date": "2025-06-30",
    "excerpt": "Functions vs closures in Rust, covering ownership, traits, lifetimes, and performance implications.",
    "content": "Understanding the distinction between functions and closures is fundamental to mastering Rust's ownership system and performance characteristics.\n\n## Key Differences\n\n| Functions | Closures |\n|-----------|----------|\n| Defined at compile time with `fn` | Anonymous, created at runtime |\n| Static dispatch (no runtime overhead) | May involve dynamic dispatch (trait objects) |\n| Cannot capture environment variables | Can capture variables from enclosing scope |\n| Always have a known type | Type is unique and inferred (each closure has its own type) |\n\n## Underlying Mechanics\n\n### Closures Are Structs + Traits\n\nRust models closures as structs that:\n- Store captured variables (as fields)\n- Implement one of the closure traits (`Fn`, `FnMut`, or `FnOnce`)\n\nFor example, this closure:\n```rust\nlet x = 42;\nlet closure = |y| x + y;\n```\n\nIs desugared to something like:\n```rust\nstruct AnonymousClosure {\n    x: i32,  // Captured variable\n}\n\nimpl FnOnce<(i32,)> for AnonymousClosure {\n    type Output = i32;\n    fn call_once(self, y: i32) -> i32 {\n        self.x + y\n    }\n}\n```\n\n### Dynamic Dispatch (Vtables)\n\nWhen closures are trait objects (e.g., `Box<dyn Fn(i32) -> i32>`), Rust uses vtables for dynamic dispatch:\n- **Vtable**: A lookup table storing function pointers, enabling runtime polymorphism\n- **Overhead**: Indirect function calls (~2‚Äì3x slower than static dispatch)\n\n## When to Use Each\n\nUse **Functions** when:\n- You need zero-cost abstractions (e.g., mathematical operations)\n- No environment capture is required\n\n```rust\nfn add(a: i32, b: i32) -> i32 { a + b }\n```\n\nUse **Closures** when:\n- You need to capture state from the environment\n- Writing short, ad-hoc logic (e.g., callbacks, iterators)\n\n```rust\nlet threshold = 10;\nlet filter = |x: i32| x > threshold;  // Captures `threshold`\n```\n\n## Performance Considerations\n\n| Scenario | Static Dispatch (Closures) | Dynamic Dispatch (dyn Fn) |\n|----------|----------------------------|----------------------------|\n| Speed | Fast (inlined) | Slower (vtable lookup) |\n| Memory | No overhead | Vtable + fat pointer |\n| Use Case | Hot loops, embedded | Heterogeneous callbacks |\n\n## Example: Static vs. Dynamic Dispatch\n\n```rust\n// Static dispatch (compile-time)\nfn static_call<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {\n    f(x)  // Inlined\n}\n\n// Dynamic dispatch (runtime)\nfn dynamic_call(f: &dyn Fn(i32) -> i32, x: i32) -> i32 {\n    f(x)  // Vtable lookup\n}\n```\n\n## Key Takeaways\n\n‚úÖ **Functions**: Predictable performance, no captures  \n‚úÖ **Closures**: Flexible, capture environment, but may involve vtables  \nüöÄ Prefer static dispatch (`impl Fn`) unless you need trait objects\n\n**Try This:** What happens if a closure captures a mutable reference and is called twice?  \n**Answer:** The borrow checker ensures exclusive access‚Äîit won't compile unless the first call completes!",
    "contentHtml": "<p>Understanding the distinction between functions and closures is fundamental to mastering Rust&#39;s ownership system and performance characteristics.</p>\n<h2>Key Differences</h2>\n<table>\n<thead>\n<tr>\n<th>Functions</th>\n<th>Closures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Defined at compile time with <code>fn</code></td>\n<td>Anonymous, created at runtime</td>\n</tr>\n<tr>\n<td>Static dispatch (no runtime overhead)</td>\n<td>May involve dynamic dispatch (trait objects)</td>\n</tr>\n<tr>\n<td>Cannot capture environment variables</td>\n<td>Can capture variables from enclosing scope</td>\n</tr>\n<tr>\n<td>Always have a known type</td>\n<td>Type is unique and inferred (each closure has its own type)</td>\n</tr>\n</tbody></table>\n<h2>Underlying Mechanics</h2>\n<h3>Closures Are Structs + Traits</h3>\n<p>Rust models closures as structs that:</p>\n<ul>\n<li>Store captured variables (as fields)</li>\n<li>Implement one of the closure traits (<code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>)</li>\n</ul>\n<p>For example, this closure:</p>\n<pre><code class=\"language-rust\">let x = 42;\nlet closure = |y| x + y;\n</code></pre>\n<p>Is desugared to something like:</p>\n<pre><code class=\"language-rust\">struct AnonymousClosure {\n    x: i32,  // Captured variable\n}\n\nimpl FnOnce&lt;(i32,)&gt; for AnonymousClosure {\n    type Output = i32;\n    fn call_once(self, y: i32) -&gt; i32 {\n        self.x + y\n    }\n}\n</code></pre>\n<h3>Dynamic Dispatch (Vtables)</h3>\n<p>When closures are trait objects (e.g., <code>Box&lt;dyn Fn(i32) -&gt; i32&gt;</code>), Rust uses vtables for dynamic dispatch:</p>\n<ul>\n<li><strong>Vtable</strong>: A lookup table storing function pointers, enabling runtime polymorphism</li>\n<li><strong>Overhead</strong>: Indirect function calls (~2‚Äì3x slower than static dispatch)</li>\n</ul>\n<h2>When to Use Each</h2>\n<p>Use <strong>Functions</strong> when:</p>\n<ul>\n<li>You need zero-cost abstractions (e.g., mathematical operations)</li>\n<li>No environment capture is required</li>\n</ul>\n<pre><code class=\"language-rust\">fn add(a: i32, b: i32) -&gt; i32 { a + b }\n</code></pre>\n<p>Use <strong>Closures</strong> when:</p>\n<ul>\n<li>You need to capture state from the environment</li>\n<li>Writing short, ad-hoc logic (e.g., callbacks, iterators)</li>\n</ul>\n<pre><code class=\"language-rust\">let threshold = 10;\nlet filter = |x: i32| x &gt; threshold;  // Captures `threshold`\n</code></pre>\n<h2>Performance Considerations</h2>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Static Dispatch (Closures)</th>\n<th>Dynamic Dispatch (dyn Fn)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Speed</td>\n<td>Fast (inlined)</td>\n<td>Slower (vtable lookup)</td>\n</tr>\n<tr>\n<td>Memory</td>\n<td>No overhead</td>\n<td>Vtable + fat pointer</td>\n</tr>\n<tr>\n<td>Use Case</td>\n<td>Hot loops, embedded</td>\n<td>Heterogeneous callbacks</td>\n</tr>\n</tbody></table>\n<h2>Example: Static vs. Dynamic Dispatch</h2>\n<pre><code class=\"language-rust\">// Static dispatch (compile-time)\nfn static_call&lt;F: Fn(i32) -&gt; i32&gt;(f: F, x: i32) -&gt; i32 {\n    f(x)  // Inlined\n}\n\n// Dynamic dispatch (runtime)\nfn dynamic_call(f: &amp;dyn Fn(i32) -&gt; i32, x: i32) -&gt; i32 {\n    f(x)  // Vtable lookup\n}\n</code></pre>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong>Functions</strong>: Predictable performance, no captures<br>‚úÖ <strong>Closures</strong>: Flexible, capture environment, but may involve vtables<br>üöÄ Prefer static dispatch (<code>impl Fn</code>) unless you need trait objects</p>\n<p><strong>Try This:</strong> What happens if a closure captures a mutable reference and is called twice?<br><strong>Answer:</strong> The borrow checker ensures exclusive access‚Äîit won&#39;t compile unless the first call completes!</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "functions",
      "closures",
      "traits",
      "ownership"
    ],
    "readingTime": "3 min",
    "seo": {
      "title": "Functions or Closures in Rust? Know the Difference!",
      "description": "Functions vs closures in Rust, covering ownership, traits, lifetimes, and performance implications.",
      "keywords": [
        "rust",
        "functions",
        "closures",
        "traits",
        "ownership"
      ]
    },
    "headings": [
      {
        "id": "key-differences",
        "text": "Key Differences",
        "level": 2
      },
      {
        "id": "underlying-mechanics",
        "text": "Underlying Mechanics",
        "level": 2
      },
      {
        "id": "closures-are-structs-traits",
        "text": "Closures Are Structs + Traits",
        "level": 3
      },
      {
        "id": "dynamic-dispatch-vtables",
        "text": "Dynamic Dispatch (Vtables)",
        "level": 3
      },
      {
        "id": "when-to-use-each",
        "text": "When to Use Each",
        "level": 2
      },
      {
        "id": "performance-considerations",
        "text": "Performance Considerations",
        "level": 2
      },
      {
        "id": "example-static-vs-dynamic-dispatch",
        "text": "Example: Static vs. Dynamic Dispatch",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "memory-layout-optimization-rust",
    "slug": "memory-layout-optimization-rust",
    "title": "Rust's repr: Optimize Struct Memory for Cache Efficiency",
    "date": "2025-06-26",
    "excerpt": "Low-level memory optimization in Rust, covering repr attributes, cache efficiency, and performance trade-offs",
    "content": "The `repr` attribute controls struct memory layout, which is critical for low-level optimization in high-throughput systems where cache locality drives performance.\n\n## How They Work\n\n**`repr(C)`**: Enforces C-compatible layout with fields ordered sequentially as declared, adding padding to align each field to its natural alignment (e.g., `u32` aligns to 4 bytes). Ensures predictable interoperability and typically aligns well with CPU cache lines (often 64 bytes).\n\n**`repr(packed)`**: Removes all padding, packing fields tightly together regardless of alignment. Minimizes memory usage but can lead to unaligned memory accesses, which are slower on most architectures.\n\n## Optimization for Cache Locality\n\nWith `repr(C)`, the compiler adds padding to align fields, increasing struct size but ensuring efficient, aligned access:\n\n```rust\n#[repr(C)]\nstruct Data {\n    flag: bool,   // 1 byte + 3 bytes padding (on 32-bit alignment)\n    value: u32,   // 4 bytes\n    counter: u64, // 8 bytes\n}\n// Size: 16 bytes (due to padding for alignment)\n```\n\nHere, `repr(C)` ensures `value` and `counter` are aligned‚Äîgreat for loops accessing `value` repeatedly. Aligned reads are fast and cache-friendly, but padding after `flag` wastes space.\n\nWith `repr(packed)`:\n\n```rust\n#[repr(packed)]\nstruct PackedData {\n    flag: bool,   // 1 byte\n    value: u32,   // 4 bytes, unaligned\n    counter: u64, // 8 bytes, unaligned\n}\n// Size: 13 bytes (no padding)\n```\n\nThis shrinks size to 13 bytes, ideal for tight memory constraints, but unaligned accesses to `value` and `counter` incur significant performance penalties.\n\n## Trade-Offs\n\n| Aspect | `repr(C)` | `repr(packed)` |\n|--------|-----------|----------------|\n| **Performance** | Fast aligned access, cache-efficient | Slower unaligned access penalties |\n| **Memory Usage** | Larger due to padding | Minimal footprint |\n| **Portability** | Safe across platforms | Risk of UB or panics on strict architectures |\n\n- **Performance**: `repr(C)` wins for speed‚Äîaligned access is faster and cache-efficient\n- **Memory Usage**: `repr(packed)` reduces footprint, critical for large arrays or tight constraints\n- **Portability**: `repr(C)` is safer; `repr(packed)` risks undefined behavior with unsafe dereferencing\n\n## Example Scenario\n\nReal-time packet parser in a network server processing millions of packets per second:\n\n```rust\n#[repr(C)]\nstruct Packet {\n    header: u8,   // 1 byte + 3 padding\n    id: u32,      // 4 bytes\n    payload: u64, // 8 bytes\n}\n```\n\nWith `repr(C)`, size is 16 bytes, and `id`/`payload` are aligned, speeding up field access in tight loops checking `id`. Cache locality is decent since the struct fits in a 64-byte cache line.\n\nIf using `repr(packed)` (13 bytes), I'd save 3 bytes per packet, but unaligned `id` and `payload` accesses could halve throughput due to penalties‚Äîunacceptable for this workload.\n\n**Choice**: `repr(C)` for performance-critical code. Consider reordering fields (`payload`, `id`, `header`) to group hot fields together.\n\n**Alternative scenario**: Serializing thousands of tiny structs to disk with infrequent access‚Äî`repr(packed)` might make sense to minimize storage, accepting slower deserialization.\n\n## Advanced Considerations\n\n- Use profiling tools like `perf` to confirm cache miss reductions\n- Consider `#[repr(C, packed)]` for C-compatible but packed layout\n- Field reordering can optimize cache line usage without changing `repr`\n- Test trade-offs on target hardware, especially ARM vs x86_64\n\n## Key Takeaways\n\n‚úÖ **`repr(C)`**: Choose for performance-critical code where cache efficiency matters  \n‚úÖ **`repr(packed)`**: Use for memory-constrained scenarios with infrequent access  \nüöÄ Profile cache performance before and after to validate optimizations\n\n**Try This:** What happens if you access a field in a `repr(packed)` struct through a raw pointer?  \n**Answer:** Unaligned access through raw pointers can cause panics on strict architectures or performance penalties‚Äîalways measure on your target platform!",
    "contentHtml": "<p>The <code>repr</code> attribute controls struct memory layout, which is critical for low-level optimization in high-throughput systems where cache locality drives performance.</p>\n<h2>How They Work</h2>\n<p><strong><code>repr(C)</code></strong>: Enforces C-compatible layout with fields ordered sequentially as declared, adding padding to align each field to its natural alignment (e.g., <code>u32</code> aligns to 4 bytes). Ensures predictable interoperability and typically aligns well with CPU cache lines (often 64 bytes).</p>\n<p><strong><code>repr(packed)</code></strong>: Removes all padding, packing fields tightly together regardless of alignment. Minimizes memory usage but can lead to unaligned memory accesses, which are slower on most architectures.</p>\n<h2>Optimization for Cache Locality</h2>\n<p>With <code>repr(C)</code>, the compiler adds padding to align fields, increasing struct size but ensuring efficient, aligned access:</p>\n<pre><code class=\"language-rust\">#[repr(C)]\nstruct Data {\n    flag: bool,   // 1 byte + 3 bytes padding (on 32-bit alignment)\n    value: u32,   // 4 bytes\n    counter: u64, // 8 bytes\n}\n// Size: 16 bytes (due to padding for alignment)\n</code></pre>\n<p>Here, <code>repr(C)</code> ensures <code>value</code> and <code>counter</code> are aligned‚Äîgreat for loops accessing <code>value</code> repeatedly. Aligned reads are fast and cache-friendly, but padding after <code>flag</code> wastes space.</p>\n<p>With <code>repr(packed)</code>:</p>\n<pre><code class=\"language-rust\">#[repr(packed)]\nstruct PackedData {\n    flag: bool,   // 1 byte\n    value: u32,   // 4 bytes, unaligned\n    counter: u64, // 8 bytes, unaligned\n}\n// Size: 13 bytes (no padding)\n</code></pre>\n<p>This shrinks size to 13 bytes, ideal for tight memory constraints, but unaligned accesses to <code>value</code> and <code>counter</code> incur significant performance penalties.</p>\n<h2>Trade-Offs</h2>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th><code>repr(C)</code></th>\n<th><code>repr(packed)</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Performance</strong></td>\n<td>Fast aligned access, cache-efficient</td>\n<td>Slower unaligned access penalties</td>\n</tr>\n<tr>\n<td><strong>Memory Usage</strong></td>\n<td>Larger due to padding</td>\n<td>Minimal footprint</td>\n</tr>\n<tr>\n<td><strong>Portability</strong></td>\n<td>Safe across platforms</td>\n<td>Risk of UB or panics on strict architectures</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>Performance</strong>: <code>repr(C)</code> wins for speed‚Äîaligned access is faster and cache-efficient</li>\n<li><strong>Memory Usage</strong>: <code>repr(packed)</code> reduces footprint, critical for large arrays or tight constraints</li>\n<li><strong>Portability</strong>: <code>repr(C)</code> is safer; <code>repr(packed)</code> risks undefined behavior with unsafe dereferencing</li>\n</ul>\n<h2>Example Scenario</h2>\n<p>Real-time packet parser in a network server processing millions of packets per second:</p>\n<pre><code class=\"language-rust\">#[repr(C)]\nstruct Packet {\n    header: u8,   // 1 byte + 3 padding\n    id: u32,      // 4 bytes\n    payload: u64, // 8 bytes\n}\n</code></pre>\n<p>With <code>repr(C)</code>, size is 16 bytes, and <code>id</code>/<code>payload</code> are aligned, speeding up field access in tight loops checking <code>id</code>. Cache locality is decent since the struct fits in a 64-byte cache line.</p>\n<p>If using <code>repr(packed)</code> (13 bytes), I&#39;d save 3 bytes per packet, but unaligned <code>id</code> and <code>payload</code> accesses could halve throughput due to penalties‚Äîunacceptable for this workload.</p>\n<p><strong>Choice</strong>: <code>repr(C)</code> for performance-critical code. Consider reordering fields (<code>payload</code>, <code>id</code>, <code>header</code>) to group hot fields together.</p>\n<p><strong>Alternative scenario</strong>: Serializing thousands of tiny structs to disk with infrequent access‚Äî<code>repr(packed)</code> might make sense to minimize storage, accepting slower deserialization.</p>\n<h2>Advanced Considerations</h2>\n<ul>\n<li>Use profiling tools like <code>perf</code> to confirm cache miss reductions</li>\n<li>Consider <code>#[repr(C, packed)]</code> for C-compatible but packed layout</li>\n<li>Field reordering can optimize cache line usage without changing <code>repr</code></li>\n<li>Test trade-offs on target hardware, especially ARM vs x86_64</li>\n</ul>\n<h2>Key Takeaways</h2>\n<p>‚úÖ <strong><code>repr(C)</code></strong>: Choose for performance-critical code where cache efficiency matters<br>‚úÖ <strong><code>repr(packed)</code></strong>: Use for memory-constrained scenarios with infrequent access<br>üöÄ Profile cache performance before and after to validate optimizations</p>\n<p><strong>Try This:</strong> What happens if you access a field in a <code>repr(packed)</code> struct through a raw pointer?<br><strong>Answer:</strong> Unaligned access through raw pointers can cause panics on strict architectures or performance penalties‚Äîalways measure on your target platform!</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "optimization",
      "memory",
      "performance",
      "cache"
    ],
    "readingTime": "3 min",
    "seo": {
      "title": "Rust's repr: Optimize Struct Memory for Cache Efficiency",
      "description": "Low-level memory optimization in Rust, covering repr attributes, cache efficiency, and performance trade-offs",
      "keywords": [
        "rust",
        "optimization",
        "memory",
        "performance",
        "cache"
      ]
    },
    "headings": [
      {
        "id": "how-they-work",
        "text": "How They Work",
        "level": 2
      },
      {
        "id": "optimization-for-cache-locality",
        "text": "Optimization for Cache Locality",
        "level": 2
      },
      {
        "id": "trade-offs",
        "text": "Trade-Offs",
        "level": 2
      },
      {
        "id": "example-scenario",
        "text": "Example Scenario",
        "level": 2
      },
      {
        "id": "advanced-considerations",
        "text": "Advanced Considerations",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "vec-new-vs-with-capacity",
    "slug": "vec-new-vs-with-capacity",
    "title": "Rust Vec::new() vs. with_capacity(): When to Use Each",
    "date": "2025-06-25",
    "excerpt": "Vec allocation strategies in Rust, comparing Vec::new() and Vec::with_capacity() for optimal performance.",
    "content": "Understanding Vec allocation strategies is crucial for writing performant Rust code, especially when dealing with collections and iterators.\n\n## Key Differences\n\n| `Vec::new()` | `Vec::with_capacity(n)` |\n|--------------|-------------------------|\n| Creates an empty Vec with no pre-allocated space | Creates an empty Vec with space for n elements |\n| Initial capacity is 0 (allocates on first push) | Initial capacity is exactly n (no early allocations) |\n| Grows dynamically (may reallocate multiple times) | Avoids reallocation until len() > n |\n\n## When to Use Each\n\nUse `Vec::new()` when:\n- The number of elements is unknown or small\n- You want simplicity (e.g., short-lived vectors)\n\n```rust\nlet mut v = Vec::new(); // Good for ad-hoc usage\nv.push(1);\n```\n\nUse `Vec::with_capacity(n)` when:\n- You know the exact or maximum number of elements upfront\n- Optimizing for performance (avoids reallocations)\n\n```rust\nlet mut v = Vec::with_capacity(1000); // Pre-allocate for 1000 items\nfor i in 0..1000 {\n    v.push(i); // No reallocation happens\n}\n```\n\n## Performance Impact\n\n`Vec::new()` may trigger multiple reallocations as it grows (e.g., starts at 0, then 4, 8, 16, ...).\n`Vec::with_capacity(n)` guarantees one allocation upfront (if n is correct).\n\n## Example Benchmark\n\n```rust\nuse std::time::Instant;\n\nfn main() {\n    let start = Instant::now();\n    let mut v1 = Vec::new();\n    for i in 0..1_000_000 {\n        v1.push(i); // Reallocates ~20 times\n    }\n    println!(\"Vec::new(): {:?}\", start.elapsed());\n\n    let start = Instant::now();\n    let mut v2 = Vec::with_capacity(1_000_000);\n    for i in 0..1_000_000 {\n        v2.push(i); // No reallocations\n    }\n    println!(\"Vec::with_capacity(): {:?}\", start.elapsed());\n}\n```\n\nOutput (typical):\n```\nVec::new(): 1.2ms\nVec::with_capacity(): 0.3ms  // 4x faster\n```\n\n## Advanced Notes\n\n- `shrink_to_fit()`: Reduces excess capacity (e.g., after removing elements)\n- `vec![]` macro: Uses with_capacity implicitly for literals (e.g., vec![1, 2, 3])\n\n## Key Takeaways\n\n‚úÖ Default to `Vec::new()` for simplicity.  \n‚úÖ Use `with_capacity(n)` when:\n- You know the size upfront\n- Performance is critical (e.g., hot loops)\n\n**Try This:** What happens if you push beyond the pre-allocated capacity?  \n**Answer:** The Vec grows automatically (like `Vec::new()`), but only after exceeding n.",
    "contentHtml": "<p>Understanding Vec allocation strategies is crucial for writing performant Rust code, especially when dealing with collections and iterators.</p>\n<h2>Key Differences</h2>\n<table>\n<thead>\n<tr>\n<th><code>Vec::new()</code></th>\n<th><code>Vec::with_capacity(n)</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Creates an empty Vec with no pre-allocated space</td>\n<td>Creates an empty Vec with space for n elements</td>\n</tr>\n<tr>\n<td>Initial capacity is 0 (allocates on first push)</td>\n<td>Initial capacity is exactly n (no early allocations)</td>\n</tr>\n<tr>\n<td>Grows dynamically (may reallocate multiple times)</td>\n<td>Avoids reallocation until len() &gt; n</td>\n</tr>\n</tbody></table>\n<h2>When to Use Each</h2>\n<p>Use <code>Vec::new()</code> when:</p>\n<ul>\n<li>The number of elements is unknown or small</li>\n<li>You want simplicity (e.g., short-lived vectors)</li>\n</ul>\n<pre><code class=\"language-rust\">let mut v = Vec::new(); // Good for ad-hoc usage\nv.push(1);\n</code></pre>\n<p>Use <code>Vec::with_capacity(n)</code> when:</p>\n<ul>\n<li>You know the exact or maximum number of elements upfront</li>\n<li>Optimizing for performance (avoids reallocations)</li>\n</ul>\n<pre><code class=\"language-rust\">let mut v = Vec::with_capacity(1000); // Pre-allocate for 1000 items\nfor i in 0..1000 {\n    v.push(i); // No reallocation happens\n}\n</code></pre>\n<h2>Performance Impact</h2>\n<p><code>Vec::new()</code> may trigger multiple reallocations as it grows (e.g., starts at 0, then 4, 8, 16, ...).\n<code>Vec::with_capacity(n)</code> guarantees one allocation upfront (if n is correct).</p>\n<h2>Example Benchmark</h2>\n<pre><code class=\"language-rust\">use std::time::Instant;\n\nfn main() {\n    let start = Instant::now();\n    let mut v1 = Vec::new();\n    for i in 0..1_000_000 {\n        v1.push(i); // Reallocates ~20 times\n    }\n    println!(&quot;Vec::new(): {:?}&quot;, start.elapsed());\n\n    let start = Instant::now();\n    let mut v2 = Vec::with_capacity(1_000_000);\n    for i in 0..1_000_000 {\n        v2.push(i); // No reallocations\n    }\n    println!(&quot;Vec::with_capacity(): {:?}&quot;, start.elapsed());\n}\n</code></pre>\n<p>Output (typical):</p>\n<pre><code>Vec::new(): 1.2ms\nVec::with_capacity(): 0.3ms  // 4x faster\n</code></pre>\n<h2>Advanced Notes</h2>\n<ul>\n<li><code>shrink_to_fit()</code>: Reduces excess capacity (e.g., after removing elements)</li>\n<li><code>vec![]</code> macro: Uses with_capacity implicitly for literals (e.g., vec![1, 2, 3])</li>\n</ul>\n<h2>Key Takeaways</h2>\n<p>‚úÖ Default to <code>Vec::new()</code> for simplicity.<br>‚úÖ Use <code>with_capacity(n)</code> when:</p>\n<ul>\n<li>You know the size upfront</li>\n<li>Performance is critical (e.g., hot loops)</li>\n</ul>\n<p><strong>Try This:</strong> What happens if you push beyond the pre-allocated capacity?<br><strong>Answer:</strong> The Vec grows automatically (like <code>Vec::new()</code>), but only after exceeding n.</p>\n",
    "author": "mayo",
    "category": "rust",
    "tags": [
      "rust",
      "collections",
      "performance",
      "vec",
      "iterators"
    ],
    "readingTime": "2 min",
    "seo": {
      "title": "Rust Vec::new() vs. with_capacity(): When to Use Each",
      "description": "Vec allocation strategies in Rust, comparing Vec::new() and Vec::with_capacity() for optimal performance.",
      "keywords": [
        "rust",
        "collections",
        "performance",
        "vec",
        "iterators"
      ]
    },
    "headings": [
      {
        "id": "key-differences",
        "text": "Key Differences",
        "level": 2
      },
      {
        "id": "when-to-use-each",
        "text": "When to Use Each",
        "level": 2
      },
      {
        "id": "performance-impact",
        "text": "Performance Impact",
        "level": 2
      },
      {
        "id": "example-benchmark",
        "text": "Example Benchmark",
        "level": 2
      },
      {
        "id": "advanced-notes",
        "text": "Advanced Notes",
        "level": 2
      },
      {
        "id": "key-takeaways",
        "text": "Key Takeaways",
        "level": 2
      }
    ]
  },
  {
    "id": "getting-started-with-rust",
    "slug": "getting-started-with-rust",
    "title": "Getting Started with Rust: A Guide for Beginners",
    "date": "2025-04-15",
    "excerpt": "Introduction to Rust for beginners, covering installation, basic syntax, and your first project.",
    "content": "Rust has been gaining significant traction among developers for its focus on performance, memory safety, and concurrency. If you're new to Rust, this guide will help you get started with the basics.\n\n## Setting Up Your Environment\n\nFirst, you'll need to install Rust on your system. The easiest way is to use rustup, the Rust toolchain installer:\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\nThis command will download a script and start the installation process. Follow the instructions on screen to complete the installation.\n\n## Your First Rust Program\n\nLet's create a simple \"Hello, World!\" program. Create a new file called `hello.rs` with the following content:\n\n```rust\nfn main() {\n    println!(\"Hello, World!\");\n}\n```\n\nTo compile and run this program, use the following commands:\n\n```bash\nrustc hello.rs\n./hello\n```\n\n## Understanding Cargo\n\nCargo is Rust's build system and package manager. It handles many tasks such as building your code, downloading libraries, and building those libraries.\n\nTo create a new project with Cargo:\n\n```bash\ncargo new hello_cargo\ncd hello_cargo\n```\n\nThis creates a new directory called `hello_cargo` with the following structure:\n\n```\nhello_cargo/\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src/\n    ‚îî‚îÄ‚îÄ main.rs\n```\n\nThe `Cargo.toml` file contains metadata about your project and its dependencies. The `src/main.rs` file contains your application code.\n\nTo build and run your project:\n\n```bash\ncargo build   # Compile the project\ncargo run     # Compile and run the project\n```\n\n## Key Concepts in Rust\n\n### Variables and Mutability\n\nBy default, variables in Rust are immutable:\n\n```rust\nlet x = 5;\n// x = 6; // This would cause an error\n```\n\nTo make a variable mutable, use the `mut` keyword:\n\n```rust\nlet mut y = 5;\ny = 6; // This works fine\n```\n\n### Ownership\n\nOwnership is Rust's most unique feature and enables memory safety without garbage collection. The main rules are:\n\n1. Each value in Rust has a variable that's its owner.\n2. There can only be one owner at a time.\n3. When the owner goes out of scope, the value will be dropped.\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1; // s1 is moved to s2, s1 is no longer valid\n    \n    // println!(\"{}\", s1); // This would cause an error\n    println!(\"{}\", s2); // This works fine\n}\n```\n\n## Next Steps\n\nNow that you have the basics, try building a small project to practice your skills. The Rust documentation is an excellent resource for learning more:\n\n- [The Rust Book](https://doc.rust-lang.org/book/)\n- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)\n\nHappy coding with Rust!",
    "contentHtml": "<p>Rust has been gaining significant traction among developers for its focus on performance, memory safety, and concurrency. If you&#39;re new to Rust, this guide will help you get started with the basics.</p>\n<h2>Setting Up Your Environment</h2>\n<p>First, you&#39;ll need to install Rust on your system. The easiest way is to use rustup, the Rust toolchain installer:</p>\n<pre><code class=\"language-bash\">curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>\n<p>This command will download a script and start the installation process. Follow the instructions on screen to complete the installation.</p>\n<h2>Your First Rust Program</h2>\n<p>Let&#39;s create a simple &quot;Hello, World!&quot; program. Create a new file called <code>hello.rs</code> with the following content:</p>\n<pre><code class=\"language-rust\">fn main() {\n    println!(&quot;Hello, World!&quot;);\n}\n</code></pre>\n<p>To compile and run this program, use the following commands:</p>\n<pre><code class=\"language-bash\">rustc hello.rs\n./hello\n</code></pre>\n<h2>Understanding Cargo</h2>\n<p>Cargo is Rust&#39;s build system and package manager. It handles many tasks such as building your code, downloading libraries, and building those libraries.</p>\n<p>To create a new project with Cargo:</p>\n<pre><code class=\"language-bash\">cargo new hello_cargo\ncd hello_cargo\n</code></pre>\n<p>This creates a new directory called <code>hello_cargo</code> with the following structure:</p>\n<pre><code>hello_cargo/\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src/\n    ‚îî‚îÄ‚îÄ main.rs\n</code></pre>\n<p>The <code>Cargo.toml</code> file contains metadata about your project and its dependencies. The <code>src/main.rs</code> file contains your application code.</p>\n<p>To build and run your project:</p>\n<pre><code class=\"language-bash\">cargo build   # Compile the project\ncargo run     # Compile and run the project\n</code></pre>\n<h2>Key Concepts in Rust</h2>\n<h3>Variables and Mutability</h3>\n<p>By default, variables in Rust are immutable:</p>\n<pre><code class=\"language-rust\">let x = 5;\n// x = 6; // This would cause an error\n</code></pre>\n<p>To make a variable mutable, use the <code>mut</code> keyword:</p>\n<pre><code class=\"language-rust\">let mut y = 5;\ny = 6; // This works fine\n</code></pre>\n<h3>Ownership</h3>\n<p>Ownership is Rust&#39;s most unique feature and enables memory safety without garbage collection. The main rules are:</p>\n<ol>\n<li>Each value in Rust has a variable that&#39;s its owner.</li>\n<li>There can only be one owner at a time.</li>\n<li>When the owner goes out of scope, the value will be dropped.</li>\n</ol>\n<pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    let s2 = s1; // s1 is moved to s2, s1 is no longer valid\n    \n    // println!(&quot;{}&quot;, s1); // This would cause an error\n    println!(&quot;{}&quot;, s2); // This works fine\n}\n</code></pre>\n<h2>Next Steps</h2>\n<p>Now that you have the basics, try building a small project to practice your skills. The Rust documentation is an excellent resource for learning more:</p>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">The Rust Book</a></li>\n<li><a href=\"https://doc.rust-lang.org/rust-by-example/\">Rust by Example</a></li>\n</ul>\n<p>Happy coding with Rust!</p>\n",
    "author": "Mayorana",
    "category": "rust",
    "tags": [
      "rust",
      "programming",
      "beginners",
      "tutorial"
    ],
    "readingTime": "3 min",
    "seo": {
      "title": "Getting Started with Rust: A Guide for Beginners",
      "description": "Introduction to Rust for beginners, covering installation, basic syntax, and your first project.",
      "keywords": [
        "rust",
        "programming",
        "beginners",
        "tutorial"
      ]
    },
    "headings": [
      {
        "id": "setting-up-your-environment",
        "text": "Setting Up Your Environment",
        "level": 2
      },
      {
        "id": "your-first-rust-program",
        "text": "Your First Rust Program",
        "level": 2
      },
      {
        "id": "understanding-cargo",
        "text": "Understanding Cargo",
        "level": 2
      },
      {
        "id": "key-concepts-in-rust",
        "text": "Key Concepts in Rust",
        "level": 2
      },
      {
        "id": "variables-and-mutability",
        "text": "Variables and Mutability",
        "level": 3
      },
      {
        "id": "ownership",
        "text": "Ownership",
        "level": 3
      },
      {
        "id": "next-steps",
        "text": "Next Steps",
        "level": 2
      }
    ]
  }
]