content_focus: "rust memory and string"
technical_level: "Expert technical discussion"
title: "Explain Rust's approach to concurrency. How do ownership and borrowing prevent data races?"
author: "mayo"
tags:
  - ""
  - ""

# Multi-line research notes using block scalar
research_context: |
  Rustâ€™s Concurrency Model

  Rust guarantees thread safety at compile time through its ownership and borrowing rules, eliminating data races without a garbage collector. Key tools:

      Ownership: Ensures exclusive mutable access.

      Lifetimes: Prevent dangling references across threads.

      Sync/Send traits: Mark types safe for threading.

  How Ownership Prevents Data Races

  A data race occurs when:

      Two threads access the same data concurrently.

      At least one is a write.

      No synchronization.

  Rustâ€™s rules make this impossible in safe code:
  1. Exclusive Mutability (&mut T)

      Only one thread can hold a mutable reference at a time.

      Enforced by the borrow checker:
      rust

      let mut data = 0;
      let r1 = &mut data;  // OK
      // let r2 = &mut data;  // ERROR: cannot borrow `data` as mutable more than once

  2. No Shared Mutability Without Synchronization

      Shared references (&T) are read-only across threads.

      To mutate shared data, you must use synchronization primitives:
      rust

      use std::sync::Mutex;

      let shared = Mutex::new(42);
      let guard = shared.lock().unwrap();  // Exclusive access
      *guard += 1;  // Safe mutation

  Thread-Safe Types: Send and Sync

      Send: A type can be transferred across threads (e.g., String, Mutex<T>).

      Sync: A type can be shared between threads via references (e.g., &i32, Arc<T>).

  Example: Spawning Threads
  rust

  use std::thread;

  let value = String::from("hello");  // `String` is `Send`
  thread::spawn(move || {             // `move` transfers ownership
      println!("{}", value);          // Safe: no other thread can access `value`
  }).join().unwrap();

  Common Concurrency Tools
  Tool	Purpose	Thread Safety Mechanism
  Mutex<T>	Mutual exclusion	Locks for exclusive access
  Arc<T>	Atomic reference counting	Shared ownership across threads
  RwLock<T>	Read-write lock	Multiple readers or one writer
  mpsc channels	Message passing	Transfers ownership between threads

  Example: Shared State with Arc + Mutex
  rust

  use std::sync::{Arc, Mutex};
  use std::thread;

  let counter = Arc::new(Mutex::new(0));
  let mut handles = vec![];

  for _ in 0..10 {
      let counter = Arc::clone(&counter);
      handles.push(thread::spawn(move || {
          let mut num = counter.lock().unwrap();
          *num += 1;  // Mutex ensures exclusive access
      }));
  }

  for handle in handles {
      handle.join().unwrap();
  }
  println!("Result: {}", *counter.lock().unwrap());  // Outputs 10

  Why This Matters

      No runtime overhead: Checks happen at compile time.

      No garbage collector: Safe concurrency without GC pauses.

      Fearless parallelism: The compiler rejects unsafe patterns.

  Key Takeaways

  âœ… Ownership rules prevent:

      Concurrent mutable access (no data races).

      Dangling references (via lifetimes).
      âœ… Send/Sync enforce thread safety at compile time.
      ðŸš€ Use Mutex, Arc, or channels for shared state.

  Real-World Impact:

      Crates like rayon (parallel iterators) and tokio (async runtime) rely on these guarantees.

  Try This: What happens if you try to share a Rc<T> across threads?
  Answer: Compile error! Rc<T> isnâ€™t thread-safe (!Send). Use Arc<T> instead.
