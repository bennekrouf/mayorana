content_focus: "rust memory and string"
technical_level: "Expert technical discussion"
title: "How does Cow<'a, B> (Copy-on-Write) work in Rust? When would you use it for strings or other data?"
author: "mayo"
tags:
  - ""
  - ""

# Multi-line research notes using block scalar
research_context: |
  What is Cow?

  Cow (Copy-on-Write) is a smart pointer in Rust that provides clone-free abstraction over borrowed and owned data. It can represent:

      Borrowed data (&'a T), avoiding allocations.

      Owned data (T), allocating only when mutated.

  Definition (From std::borrow)
  rust

  pub enum Cow<'a, B>
  where
      B: 'a + ToOwned + ?Sized,
  {
      Borrowed(&'a B),  // Immutable reference (no allocation)
      Owned(<B as ToOwned>::Owned),  // Owned data (allocated when needed)
  }

  How It Works

      Initially Borrowed: Wraps a reference (zero-cost).

      Clones Only When Modified: Converts to owned data lazily.

  Example with Cow<str> (Strings)
  rust

  use std::borrow::Cow;

  fn process(input: &str) -> Cow<str> {
      if input.contains("error") {
          Cow::Owned(input.replace("error", ""))  // Allocates new String
      } else {
          Cow::Borrowed(input)  // No allocation
      }
  }

  fn main() {
      let msg1 = "hello world";  // No allocation
      let msg2 = "error: foo";   // Will allocate when processed

      println!("{}", process(msg1)); // "hello world" (borrowed)
      println!("{}", process(msg2)); // ": foo" (owned)
  }

  Key Use Cases
  1. Optimizing String Operations

  Avoid allocations when modifying strings conditionally:
  rust

  fn to_uppercase(input: &str) -> Cow<str> {
      if input.chars().any(|c| c.is_lowercase()) {
          Cow::Owned(input.to_uppercase())  // Allocates only if needed
      } else {
          Cow::Borrowed(input)
      }
  }

  2. API Flexibility

  Accept both borrowed and owned data without forcing clones:
  rust

  fn print(data: Cow<str>) {
      println!("{}", data);
  }

  print(Cow::Borrowed("hello"));  // No allocation
  print(Cow::Owned(String::from("world")));  // Works too

  3. Zero-Copy Parsing

  Common in parsers (e.g., serde), where most fields are unmodified:
  rust

  struct JsonValue<'a> {
      data: Cow<'a, str>,  // Borrows from input unless modified
  }

  When to Avoid Cow

      Always-mutated data: Just use String/Vec directly.

      Thread-safety: Cow is not thread-safe (use Arc + Mutex instead).

  Performance Implications
  Scenario	Behavior	Allocation Cost
  No modification	Stays as Borrowed	Zero
  Modification	Converts to Owned	One allocation
  Key Takeaways

  âœ… Use Cow when:

      You need to conditionally modify borrowed data.

      You want to avoid allocations for read-only paths.

      Your API should accept both &str and String efficiently.

  ðŸš€ Real-world uses:

      regex::Match (borrows input strings).

      serde deserialization.

      Path manipulation (e.g., PathBuf vs &Path).

  Try this: Modify the to_uppercase example to also check for digits. How does Cow help?

  Bonus: Cow works with any ToOwned type (e.g., [u8] â†’ Vec<u8>, Path â†’ PathBuf).
