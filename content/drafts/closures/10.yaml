content_focus: "functions and closures in Rust, covering ownership, traits, lifetimes"
technical_level: "Expert technical discussion"
title: "Compare Box<dyn Fn()> with impl Fn(). When would you choose one over the other?"
author: "mayo"
tags:
  - ""
  - ""

# Multi-line research notes using block scalar
research_context: |
  Key Differences
  Aspect	impl Fn() (Static Dispatch)	Box<dyn Fn()> (Dynamic Dispatch)
  Dispatch Mechanism	Monomorphized at compile time (zero-cost).	Uses vtables (runtime lookup).
  Performance	Faster (no heap or runtime overhead).	Slower (heap allocation + vtable lookup).
  Flexibility	Single concrete type per instance.	Can store heterogeneous closures.
  Memory	Stack-allocated (unless moved).	Heap-allocated (trait object).
  Use Case	Fixed closure type, performance-critical.	Dynamic behavior, multiple closure types.
  When to Use Each
  1. impl Fn() (Static Dispatch)

      Use When:

          The closure type is fixed and known at compile time.

          Performance is critical (e.g., hot loops or embedded systems).

          You want zero-cost abstractions.

  Example:
  rust

  // Returns a closure that adds a fixed value (no heap allocation).
  fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
      move |y| x + y
  }

  let add_five = make_adder(5); // Type: closure(5)
  println!("{}", add_five(3)); // 8

  2. Box<dyn Fn()> (Dynamic Dispatch)

      Use When:

          You need to store different closures in the same collection (e.g., callbacks).

          The closure type varies at runtime (e.g., plugin systems).

          Flexibility outweighs performance costs.

  Example:
  rust

  // Returns different closures based on a condition (heap-allocated).
  fn create_op(is_add: bool) -> Box<dyn Fn(i32, i32) -> i32> {
      if is_add {
          Box::new(|x, y| x + y)
      } else {
          Box::new(|x, y| x * y)
      }
  }

  let add = create_op(true);
  let mul = create_op(false);
  println!("{} {}", add(2, 3), mul(2, 3)); // 5 6

  Lifetime Considerations

      Box<dyn Fn()>: Often requires explicit lifetimes if the closure captures references:
      rust

      struct Handler<'a> {
          callback: Box<dyn Fn() -> &'a str + 'a>,
      }

      impl Fn(): Lifetimes are inferred unless references are captured.

  Performance Trade-offs
  Scenario	impl Fn()	Box<dyn Fn()>
  Call Speed	~1–2 ns (direct call).	~5–10 ns (vtable lookup).
  Memory Overhead	None (stack-allocated).	16–24 bytes (fat pointer + heap data).
  Code Bloat	Possible (monomorphization).	Minimal (single vtable).
  Key Takeaways

  ✅ Choose impl Fn() for:

      Performance-sensitive code.

      Single closure type (e.g., factory functions).

  ✅ Choose Box<dyn Fn()> for:

      Dynamic behavior (e.g., event handlers, plugins).

      Storing mixed closure types (e.g., Vec<Box<dyn Fn()>>).

  Real-World Example:

      impl Fn(): Used in iterator adapters like map and filter (zero-cost).

      Box<dyn Fn()>: Used in GUI frameworks for event callbacks (flexibility over speed).

  Try This: Benchmark a closure call with impl Fn vs. Box<dyn Fn> using criterion!
